<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Android TV Film Grid</title>
    <style>
        /* INLINE CSS */
        body {
            background-color: #141414;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        #status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 1000;
            font-size: 16px;
        }

        #movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));
            gap: 20px;
            padding: 80px 40px 40px 40px; /* Extra padding top for status bar */
        }

        .movie-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border-color 0.2s;
            border: 4px solid transparent;
            border-radius: 4px;
            background-color: #222;
        }

        .movie-item:focus {
            outline: none;
            border-color: #e50914;
            transform: scale(1.1);
            z-index: 10;
        }

        .movie-item img {
            width: 100%;
            height: auto;
            display: block;
            aspect-ratio: 2 / 3; /* Standaard poster ratio */
            border-radius: 2px;
        }

        .movie-title {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            padding: 20px 10px 10px 10px;
            font-size: 1em;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .movie-item:focus .movie-title {
            opacity: 1;
        }

        #loader {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            display: none; /* Standaard verborgen */
        }
    </style>
</head>
<body>

    <div id="status">Status: Initialiseren...</div>
    <div id="movie-grid"></div>
    <div id="loader">Laden van meer films...</div>

    <script>
    // INLINE JAVASCRIPT
    document.addEventListener('DOMContentLoaded', () => {
        const grid = document.getElementById('movie-grid');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('status');
        
        const TMDB_KEY_STORAGE_ID = 'tmdb_api_key';

        let currentPage = 1;
        let isLoading = false;
        let tmdbApiKey = null;
        let tmdbConfig = null;
        
        /**
         * The API key scraper function provided by the user.
         */
        async function scrapeTmdbKeys(options = {}) {
            const {
                maxPages = 20,
                onStatusUpdate = (message) => console.log(message),
                onValidKeyFound = (apiKey, totalValidKeys) => {},
                proxyTimeout = 15000,
                apiKeyTestTimeout = 20000,
                maxConcurrentKeyTests = 5
            } = options;

            const BASE_URL = 'https://grep.app/search?regexp=true&q=%28tmdb.*%5Ba-f0-9%5D%7B32%7D%7C%5Ba-f0-9%5D%7B32%7D.*tmdb%29';
            const API_KEY_REGEX = /[a-f0-9]{32}/g;
            const PROXIES = [
                (url) => `https://api.codetabs.com/v1/proxy/?quest=${encodeURIComponent(url)}`,
                (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                (url) => `https://cors.eu.org/${url.replace(/^https?:\/\//, '')}`,
                (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            let foundPotentialKeys = new Set();
            let validApiKeys = [];
            let scrapeCurrentPage = 1;
            let selectedProxyDetails = null;

            async function determineFastestProxy(baseUrlForTest, proxyList, statusUpdateFn, timeout) {
                statusUpdateFn("Bepalen van de snelste proxy...");
                const proxyPromises = proxyList.map(async (proxyBuilderFunc) => {
                    const proxyUrl = proxyBuilderFunc(baseUrlForTest);
                    const proxyNameMatch = proxyUrl.match(/https:\/\/([a-zA-Z0-9.-]+)/);
                    const proxyName = proxyNameMatch ? proxyNameMatch[1] : 'Unknown Proxy';
                    const startTime = Date.now();
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), timeout);
                        statusUpdateFn(`Test proxy: ${proxyName}...`);
                        const response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        await response.text();
                        const duration = Date.now() - startTime;
                        statusUpdateFn(`OK: ${proxyName} reageerde in ${duration}ms.`);
                        return { proxyBuilder: proxyBuilderFunc, proxyName, duration, success: true };
                    } catch (error) {
                        statusUpdateFn(`FAIL: ${proxyName} (${error.name === 'AbortError' ? 'timeout' : error.message}).`);
                        return { duration: Infinity, success: false };
                    }
                });

                const results = await Promise.all(proxyPromises);
                const fastestProxy = results.filter(r => r.success).sort((a, b) => a.duration - b.duration)[0];

                if (fastestProxy) {
                    statusUpdateFn(`Snelste proxy geselecteerd: ${fastestProxy.proxyName}.`);
                    return { proxyBuilder: fastestProxy.proxyBuilder, proxyName: fastestProxy.proxyName };
                } else {
                    throw new Error("Geen werkende proxy gevonden.");
                }
            }

            async function fetchWithSelectedProxy(url, pageNum, proxyDetails, statusUpdateFn, timeout) {
                const { proxyBuilder, proxyName } = proxyDetails;
                const proxyUrl = proxyBuilder(url);
                statusUpdateFn(`Pagina ${pageNum}: Ophalen via ${proxyName}...`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.text();
                } catch (error) {
                    throw new Error(`Proxy fetch mislukt: ${error.message}`);
                }
            }

            async function testApiKeyValidity(apiKey, statusFn) {
                const shortKey = `${apiKey.substring(0, 8)}...`;
                statusFn(`Test key: ${shortKey}`);
                const tmdbApiUrl = `https://api.themoviedb.org/3/configuration?api_key=${apiKey}`;
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), apiKeyTestTimeout);
                    const response = await fetch(tmdbApiUrl, { method: 'GET', signal: controller.signal });
                    clearTimeout(timeoutId);
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }

            async function processPage(pageNum, proxyDetails) {
                onStatusUpdate(`Ophalen van pagina ${pageNum}...`);
                const urlToFetch = `${BASE_URL}&page=${pageNum}`;
                try {
                    const html = await fetchWithSelectedProxy(urlToFetch, pageNum, proxyDetails, onStatusUpdate, proxyTimeout);
                    const keysOnPage = [...new Set(html.match(API_KEY_REGEX) || [])];
                    const newKeys = keysOnPage.filter(key => !foundPotentialKeys.has(key));

                    if (newKeys.length > 0) {
                        onStatusUpdate(`Pagina ${pageNum}: ${newKeys.length} nieuwe potentiële keys gevonden. Testen...`);
                        newKeys.forEach(key => foundPotentialKeys.add(key));

                        for (let i = 0; i < newKeys.length; i += maxConcurrentKeyTests) {
                            const batch = newKeys.slice(i, i + maxConcurrentKeyTests);
                            const testPromises = batch.map(key =>
                                testApiKeyValidity(key, onStatusUpdate).then(isValid => ({ key, isValid }))
                            );
                            const results = await Promise.all(testPromises);
                            results.forEach(result => {
                                if (result.isValid) {
                                    validApiKeys.push(result.key);
                                    onValidKeyFound(result.key, validApiKeys.length);
                                }
                            });
                        }
                    } else {
                        onStatusUpdate(`Pagina ${pageNum}: Geen nieuwe potentiële keys gevonden.`);
                    }
                    return html.includes('Load More Results') || html.includes('loadMoreResults');
                } catch (error) {
                    onStatusUpdate(`Fout op pagina ${pageNum}: ${error.message}. Stoppen.`);
                    return false;
                }
            }

            onStatusUpdate("Starten van key scraping proces...");
            try {
                selectedProxyDetails = await determineFastestProxy(BASE_URL, PROXIES, onStatusUpdate, proxyTimeout);
            } catch (error) {
                onStatusUpdate(`Scrapen afgebroken: ${error.message}`);
                return [];
            }

            let hasMore = true;
            while (hasMore && scrapeCurrentPage <= maxPages) {
                onStatusUpdate(`--- Verwerken van pagina ${scrapeCurrentPage}/${maxPages} ---`);
                hasMore = await processPage(scrapeCurrentPage, selectedProxyDetails);
                if (hasMore) scrapeCurrentPage++;
                // Stop zodra we ten minste één geldige sleutel hebben
                if (validApiKeys.length > 0) {
                    onStatusUpdate("Geldige API key gevonden. Stoppen met scrapen.");
                    hasMore = false; 
                }
            }
            
            onStatusUpdate(`Scrapen voltooid. ${validApiKeys.length} geldige key(s) gevonden.`);
            return validApiKeys;
        }


        async function getApiKey() {
            let key = localStorage.getItem(TMDB_KEY_STORAGE_ID);
            if (key) {
                statusDiv.textContent = 'Opgeslagen API key gevonden.';
                return key;
            }

            statusDiv.textContent = 'Geen opgeslagen API key. Starten van scraper...';
            const keys = await scrapeTmdbKeys({
                maxPages: 5, // Beperk het zoeken om het snel te houden
                onStatusUpdate: (message) => {
                    console.log(message);
                    statusDiv.textContent = `Scraper: ${message}`;
                }
            });

            if (keys.length > 0) {
                key = keys[0];
                localStorage.setItem(TMDB_KEY_STORAGE_ID, key);
                statusDiv.textContent = 'Nieuwe API key gevonden en opgeslagen.';
                return key;
            } else {
                throw new Error('Kon geen geldige TMDb API key vinden.');
            }
        }

        async function fetchTmdbConfig() {
            try {
                const response = await fetch(`https://api.themoviedb.org/3/configuration?api_key=${tmdbApiKey}`);
                if (!response.ok) throw new Error('Kon TMDb configuratie niet ophalen');
                const data = await response.json();
                tmdbConfig = data;
                statusDiv.textContent = 'Klaar. Navigeer met pijltoetsen.';
            } catch (error) {
                statusDiv.textContent = `Fout: ${error.message}. Probeer de pagina te vernieuwen.`;
                console.error(error);
            }
        }
        
        async function fetchPosterPath(tmdbId) {
            if (!tmdbApiKey || !tmdbId) return null;
            try {
                const url = `https://api.themoviedb.org/3/movie/${tmdbId}?api_key=${tmdbApiKey}`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return data.poster_path;
            } catch (error) {
                console.error(`Fout bij ophalen poster voor tmdb_id ${tmdbId}:`, error);
                return null;
            }
        }

        async function fetchAndDisplayMovies() {
            if (isLoading) return;
            isLoading = true;
            loader.style.display = 'block';

            try {
                const response = await fetch(`https://vidsrc.xyz/movies/latest/page-${currentPage}.json`);
                const data = await response.json();

                if (data.result && data.result.length > 0) {
                    for (const movie of data.result) {
                        const posterPath = await fetchPosterPath(movie.tmdb_id);
                        
                        const movieItem = document.createElement('div');
                        movieItem.className = 'movie-item';
                        movieItem.tabIndex = 0; // Maak het item focusseerbaar
                        movieItem.dataset.title = movie.title;
                        movieItem.dataset.embedUrl = movie.embed_url_tmdb;

                        const img = document.createElement('img');
                        if (posterPath && tmdbConfig) {
                           img.src = `${tmdbConfig.images.secure_base_url}w342${posterPath}`;
                        } else {
                           img.src = 'https://via.placeholder.com/342x513.png?text=Geen+Poster'; // Placeholder
                        }
                        img.alt = movie.title;

                        const title = document.createElement('div');
                        title.className = 'movie-title';
                        title.textContent = movie.title;

                        movieItem.appendChild(img);
                        movieItem.appendChild(title);
                        grid.appendChild(movieItem);
                    }
                    currentPage++;
                } else {
                    // Geen films meer, stop de observer
                    observer.unobserve(loader);
                    loader.textContent = 'Einde van de lijst.';
                }
            } catch (error) {
                console.error('Fout bij het ophalen van films:', error);
                loader.textContent = 'Er is een fout opgetreden.';
            } finally {
                isLoading = false;
                loader.style.display = 'none';
            }
        }

        // Lazy loading met Intersection Observer
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !isLoading) {
                fetchAndDisplayMovies();
            }
        }, { rootMargin: '200px' });

        // D-pad navigatie logica
        grid.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            if (!activeElement || !activeElement.classList.contains('movie-item')) {
                return;
            }

            e.preventDefault();

            const items = Array.from(grid.querySelectorAll('.movie-item'));
            const currentIndex = items.indexOf(activeElement);
            
            const style = window.getComputedStyle(grid);
            const columnCount = style.gridTemplateColumns.split(' ').length;
            
            let nextIndex = -1;

            switch (e.key) {
                case 'ArrowUp':
                    nextIndex = currentIndex - columnCount;
                    break;
                case 'ArrowDown':
                    nextIndex = currentIndex + columnCount;
                    break;
                case 'ArrowLeft':
                    nextIndex = currentIndex - 1;
                    break;
                case 'ArrowRight':
                    nextIndex = currentIndex + 1;
                    break;
                case 'Enter':
                case 'Ok': // Sommige TV's sturen 'Ok'
                    alert(`Starten van film: ${activeElement.dataset.title}\nURL: ${activeElement.dataset.embedUrl}`);
                    return;
            }

            if (nextIndex >= 0 && nextIndex < items.length) {
                items[nextIndex].focus();
            }
        });

        // Initialisatie
        async function initialize() {
            try {
                tmdbApiKey = await getApiKey();
                await fetchTmdbConfig();
                if (tmdbApiKey && tmdbConfig) {
                    await fetchAndDisplayMovies();
                    observer.observe(loader); // Start lazy loading
                     // Set initial focus
                    setTimeout(() => {
                        const firstItem = grid.querySelector('.movie-item');
                        if (firstItem) {
                            firstItem.focus();
                        }
                    }, 500);
                }
            } catch (error) {
                statusDiv.textContent = `Initialisatie mislukt: ${error.message}`;
                console.error(error);
            }
        }
        
        initialize();
    });
    </script>
</body>
</html>