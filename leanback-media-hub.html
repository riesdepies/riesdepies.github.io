<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Android TV Film Grid</title>
    <style>
        /* INLINE CSS */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background-color: #141414;
            color: #fff;
            font-family: Arial, sans-serif;
            position: relative;
        }

        #movie-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(2, 44vh); 
            gap: 20px;
            box-sizing: border-box;
            width: 95vw;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: filter 0.3s;
        }
        
        body.player-active #movie-grid {
            filter: blur(8px);
        }

        .movie-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border-color 0.2s;
            border: 4px solid transparent;
            border-radius: 4px;
            background-color: #222;
        }

        .movie-item:focus {
            outline: none;
            border-color: #e50914;
            transform: scale(1.1);
            z-index: 10;
        }

        .movie-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 2px;
        }

        .movie-title {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            padding: 20px 10px 10px 10px;
            font-size: 1em;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .movie-item:focus .movie-title {
            opacity: 1;
        }
        
        #toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 25px;
            border-radius: 25px;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        #toast.show {
            opacity: 1;
            visibility: visible;
        }
        
        #player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #player-frame {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>

    <div id="movie-grid"></div>
    <div id="toast"></div>
    
    <div id="player-container">
        <iframe id="player-frame" allowfullscreen></iframe>
    </div>

    <script>
    // INLINE JAVASCRIPT
    document.addEventListener('DOMContentLoaded', () => {
        const grid = document.getElementById('movie-grid');
        const toast = document.getElementById('toast');
        const playerContainer = document.getElementById('player-container');
        const playerFrame = document.getElementById('player-frame');
        let toastTimeout;
        
        const TMDB_KEY_STORAGE_ID = 'tmdb_api_key';
        const ROW_COUNT = 2;
        const COLUMN_COUNT = 5;
        const GRID_SIZE = ROW_COUNT * COLUMN_COUNT;

        let currentPage = 1;
        let isLoading = false;
        let tmdbApiKey = null;
        let tmdbConfig = null;
        let allMovies = [];
        let visibleRowIndex = 0;
        let lastFocusedElement = null;

        function showToast(message, duration = 3000) {
            clearTimeout(toastTimeout);
            toast.textContent = message;
            toast.classList.add('show');
            toastTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        async function scrapeTmdbKeys(options = {}) {
            const {
                maxPages = 20,
                onStatusUpdate = (message) => console.log(message),
                onValidKeyFound = (apiKey, totalValidKeys) => {},
                proxyTimeout = 15000,
                apiKeyTestTimeout = 20000,
                maxConcurrentKeyTests = 5
            } = options;

            const BASE_URL = 'https://grep.app/search?regexp=true&q=%28tmdb.*%5Ba-f0-9%5D%7B32%7D%7C%5Ba-f0-9%5D%7B32%7D.*tmdb%29';
            const API_KEY_REGEX = /[a-f0-9]{32}/g;
            const PROXIES = [
                (url) => `https://api.codetabs.com/v1/proxy/?quest=${encodeURIComponent(url)}`,
                (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                (url) => `https://cors.eu.org/${url.replace(/^https?:\/\//, '')}`,
                (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            let foundPotentialKeys = new Set();
            let validApiKeys = [];
            let scrapeCurrentPage = 1;
            let selectedProxyDetails = null;

            async function determineFastestProxy(baseUrlForTest, proxyList, statusUpdateFn, timeout) {
                statusUpdateFn("Bepalen van de snelste proxy...");
                const proxyPromises = proxyList.map(async (proxyBuilderFunc) => {
                    const proxyUrl = proxyBuilderFunc(baseUrlForTest);
                    const proxyNameMatch = proxyUrl.match(/https:\/\/([a-zA-Z0-9.-]+)/);
                    const proxyName = proxyNameMatch ? proxyNameMatch[1] : 'Unknown Proxy';
                    const startTime = Date.now();
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), timeout);
                        statusUpdateFn(`Test proxy: ${proxyName}...`);
                        const response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        await response.text();
                        const duration = Date.now() - startTime;
                        statusUpdateFn(`OK: ${proxyName} reageerde in ${duration}ms.`);
                        return { proxyBuilder: proxyBuilderFunc, proxyName, duration, success: true };
                    } catch (error) {
                        statusUpdateFn(`FAIL: ${proxyName} (${error.name === 'AbortError' ? 'timeout' : error.message}).`);
                        return { duration: Infinity, success: false };
                    }
                });

                const results = await Promise.all(proxyPromises);
                const fastestProxy = results.filter(r => r.success).sort((a, b) => a.duration - b.duration)[0];

                if (fastestProxy) {
                    statusUpdateFn(`Snelste proxy geselecteerd: ${fastestProxy.proxyName}.`);
                    return { proxyBuilder: fastestProxy.proxyBuilder, proxyName: fastestProxy.proxyName };
                } else {
                    throw new Error("Geen werkende proxy gevonden.");
                }
            }

            async function fetchWithSelectedProxy(url, pageNum, proxyDetails, statusUpdateFn, timeout) {
                const { proxyBuilder, proxyName } = proxyDetails;
                const proxyUrl = proxyBuilder(url);
                statusUpdateFn(`Pagina ${pageNum}: Ophalen via ${proxyName}...`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.text();
                } catch (error) {
                    throw new Error(`Proxy fetch mislukt: ${error.message}`);
                }
            }

            async function testApiKeyValidity(apiKey, statusFn) {
                const shortKey = `${apiKey.substring(0, 8)}...`;
                statusFn(`Test key: ${shortKey}`);
                const tmdbApiUrl = `https://api.themoviedb.org/3/configuration?api_key=${apiKey}`;
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), apiKeyTestTimeout);
                    const response = await fetch(tmdbApiUrl, { method: 'GET', signal: controller.signal });
                    clearTimeout(timeoutId);
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }

            async function processPage(pageNum, proxyDetails) {
                onStatusUpdate(`Ophalen van pagina ${pageNum}...`);
                const urlToFetch = `${BASE_URL}&page=${pageNum}`;
                try {
                    const html = await fetchWithSelectedProxy(urlToFetch, pageNum, proxyDetails, onStatusUpdate, proxyTimeout);
                    const keysOnPage = [...new Set(html.match(API_KEY_REGEX) || [])];
                    const newKeys = keysOnPage.filter(key => !foundPotentialKeys.has(key));

                    if (newKeys.length > 0) {
                        onStatusUpdate(`Pagina ${pageNum}: ${newKeys.length} nieuwe potentiële keys gevonden. Testen...`);
                        newKeys.forEach(key => foundPotentialKeys.add(key));

                        for (let i = 0; i < newKeys.length; i += maxConcurrentKeyTests) {
                            const batch = newKeys.slice(i, i + maxConcurrentKeyTests);
                            const testPromises = batch.map(key =>
                                testApiKeyValidity(key, onStatusUpdate).then(isValid => ({ key, isValid }))
                            );
                            const results = await Promise.all(testPromises);
                            results.forEach(result => {
                                if (result.isValid) {
                                    validApiKeys.push(result.key);
                                    onValidKeyFound(result.key, validApiKeys.length);
                                }
                            });
                        }
                    } else {
                        onStatusUpdate(`Pagina ${pageNum}: Geen nieuwe potentiële keys gevonden.`);
                    }
                    return html.includes('Load More Results') || html.includes('loadMoreResults');
                } catch (error) {
                    onStatusUpdate(`Fout op pagina ${pageNum}: ${error.message}. Stoppen.`);
                    return false;
                }
            }

            onStatusUpdate("Starten van key scraping proces...");
            try {
                selectedProxyDetails = await determineFastestProxy(BASE_URL, PROXIES, onStatusUpdate, proxyTimeout);
            } catch (error) {
                onStatusUpdate(`Scrapen afgebroken: ${error.message}`);
                return [];
            }

            let hasMore = true;
            while (hasMore && scrapeCurrentPage <= maxPages) {
                onStatusUpdate(`--- Verwerken van pagina ${scrapeCurrentPage}/${maxPages} ---`);
                hasMore = await processPage(scrapeCurrentPage, selectedProxyDetails);
                if (hasMore) scrapeCurrentPage++;
                if (validApiKeys.length > 0) {
                    onStatusUpdate("Geldige API key gevonden. Stoppen met scrapen.");
                    hasMore = false; 
                }
            }
            
            onStatusUpdate(`Scrapen voltooid. ${validApiKeys.length} geldige key(s) gevonden.`);
            return validApiKeys;
        }

        async function getApiKey() {
            let key = localStorage.getItem(TMDB_KEY_STORAGE_ID);
            if (key) return key;
            showToast('Bezig met configureren...', 6000);
            const keys = await scrapeTmdbKeys({
                maxPages: 5,
                onStatusUpdate: (message) => console.log(message),
            });
            if (keys.length > 0) {
                key = keys[0];
                localStorage.setItem(TMDB_KEY_STORAGE_ID, key);
                return key;
            } else { throw new Error('Kon geen geldige TMDb API key vinden.'); }
        }

        async function fetchTmdbConfig() {
            const response = await fetch(`https://api.themoviedb.org/3/configuration?api_key=${tmdbApiKey}`);
            if (!response.ok) throw new Error('Kon TMDb configuratie niet ophalen');
            tmdbConfig = await response.json();
        }
        
        async function fetchTmdbDetails(tmdbId) {
            if (!tmdbApiKey || !tmdbId) return null;
            try {
                const url = `https://api.themoviedb.org/3/movie/${tmdbId}?api_key=${tmdbApiKey}`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return { title: data.title, release_date: data.release_date, poster_path: data.poster_path };
            } catch (error) { return null; }
        }

        async function fetchMovies() {
            if (isLoading) return;
            isLoading = true;
            try {
                const response = await fetch(`https://vidsrc.xyz/movies/latest/page-${currentPage}.json`);
                const data = await response.json();
                if (data.result && data.result.length > 0) {
                    const moviePromises = data.result.map(async (movie) => {
                        const tmdbDetails = await fetchTmdbDetails(movie.tmdb_id);
                        return { ...movie, ...tmdbDetails };
                    });
                    const moviesWithDetails = await Promise.all(moviePromises);
                    allMovies.push(...moviesWithDetails);
                    currentPage++;
                }
            } catch (error) { console.error('Fout bij het ophalen van films:', error); } 
            finally { isLoading = false; }
        }
        
        function renderGrid() {
            grid.innerHTML = '';
            const startIndex = visibleRowIndex * COLUMN_COUNT;
            const moviesToRender = allMovies.slice(startIndex, startIndex + GRID_SIZE);
            for(let i = 0; i < GRID_SIZE; i++) {
                const movie = moviesToRender[i];
                const movieItem = document.createElement('div');
                movieItem.className = 'movie-item';
                if (movie) {
                    const year = movie.release_date ? movie.release_date.substring(0, 4) : '';
                    const displayTitle = year ? `${movie.title} (${year})` : movie.title;
                    movieItem.tabIndex = 0;
                    movieItem.dataset.title = displayTitle;
                    movieItem.dataset.embedUrl = movie.embed_url_tmdb;
                    const img = document.createElement('img');
                    img.src = movie.poster_path ? `${tmdbConfig.images.secure_base_url}w342${movie.poster_path}` : 'https://via.placeholder.com/342x513.png?text=Geen+Poster';
                    img.alt = displayTitle;
                    const title = document.createElement('div');
                    title.className = 'movie-title';
                    title.textContent = displayTitle;
                    movieItem.appendChild(img);
                    movieItem.appendChild(title);
                }
                grid.appendChild(movieItem);
            }
        }
        
        // WIJZIGING: Aparte functies voor openen en sluiten van de speler
        function openPlayer(url) {
            lastFocusedElement = document.activeElement;
            playerFrame.src = url;
            playerContainer.style.display = 'flex';
            document.body.classList.add('player-active');
            history.pushState({playerOpen: true}, ''); // Voeg state toe aan geschiedenis
        }
        
        function closePlayer() {
            playerContainer.style.display = 'none';
            document.body.classList.remove('player-active');
            playerFrame.src = ''; 
            if (lastFocusedElement) {
                lastFocusedElement.focus();
            }
        }

        grid.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            if (!activeElement || !activeElement.classList.contains('movie-item')) return;
            
            e.preventDefault();
            const items = Array.from(grid.querySelectorAll('.movie-item'));
            const currentIndex = items.indexOf(activeElement);
            let nextFocusIndex = -1;

            switch (e.key) {
                case 'ArrowUp':
                    if (currentIndex < COLUMN_COUNT && visibleRowIndex > 0) {
                        visibleRowIndex--;
                        renderGrid();
                        nextFocusIndex = currentIndex;
                    } else if (currentIndex >= COLUMN_COUNT) {
                        nextFocusIndex = currentIndex - COLUMN_COUNT;
                    }
                    break;
                case 'ArrowDown':
                    const maxRowIndex = Math.ceil(allMovies.length / COLUMN_COUNT) - ROW_COUNT;
                    if (currentIndex >= COLUMN_COUNT && visibleRowIndex < maxRowIndex) {
                        visibleRowIndex++;
                        renderGrid();
                        nextFocusIndex = currentIndex;
                        if (maxRowIndex - visibleRowIndex < 3 && !isLoading) {
                           showToast('Meer films laden...');
                           fetchMovies();
                        }
                    } else if (currentIndex < COLUMN_COUNT) {
                        if (items[currentIndex + COLUMN_COUNT] && items[currentIndex + COLUMN_COUNT].hasAttribute('tabindex')) {
                            nextFocusIndex = currentIndex + COLUMN_COUNT;
                        }
                    }
                    break;
                case 'ArrowLeft':
                    if (currentIndex % COLUMN_COUNT !== 0) {
                        nextFocusIndex = currentIndex - 1;
                    }
                    break;
                case 'ArrowRight':
                    if ((currentIndex + 1) % COLUMN_COUNT !== 0) {
                        if (items[currentIndex + 1] && items[currentIndex + 1].hasAttribute('tabindex')) {
                            nextFocusIndex = currentIndex + 1;
                        }
                    }
                    break;
                case 'Enter':
                case 'Ok':
                    if(activeElement.dataset.embedUrl) {
                        openPlayer(activeElement.dataset.embedUrl);
                    }
                    return;
            }

            if (nextFocusIndex !== -1) {
                requestAnimationFrame(() => {
                    const newItems = grid.querySelectorAll('.movie-item');
                    if (newItems[nextFocusIndex]) { newItems[nextFocusIndex].focus(); }
                });
            }
        });

        // WIJZIGING: Luister naar de 'popstate' event die door de 'Terug'-knop wordt getriggerd
        window.addEventListener('popstate', () => {
            if (document.body.classList.contains('player-active')) {
                closePlayer();
            }
        });

        async function initialize() {
            try {
                tmdbApiKey = await getApiKey();
                await fetchTmdbConfig();
                if (tmdbApiKey && tmdbConfig) {
                    showToast('Films laden...');
                    await fetchMovies();
                    await fetchMovies();
                    renderGrid();
                    setTimeout(() => {
                        const firstItem = grid.querySelector('.movie-item[tabindex="0"]');
                        if (firstItem) firstItem.focus();
                    }, 100);
                }
            } catch (error) {
                showToast(`Fout: ${error.message}`, 5000);
                console.error(error);
            }
        }
        
        initialize();
    });
    </script>
</body>
</html>