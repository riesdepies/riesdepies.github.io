<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Browser</title>
    <style>
        :root {
            --bg-color: #141414;
            --sidebar-bg: #101010;
            --text-color: #e5e5e5;
            --focus-color: #0071eb;
            --poster-gap: 20px;
        }

        * {
            box-sizing: border-box;
            outline: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 250px;
            background-color: var(--sidebar-bg);
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
        }
        
        #sidebar h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        #sidebar nav a {
            display: block;
            color: var(--text-color);
            text-decoration: none;
            padding: 12px 15px;
            margin: 5px 0;
            border-radius: 5px;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        #sidebar nav a:focus, #sidebar nav a:hover {
            background-color: var(--focus-color);
            color: white;
            transform: translateX(5px);
        }

        #sidebar nav a.active {
            background-color: #2a2a2a;
            font-weight: bold;
        }
        
        #genre-list {
            margin-top: 20px;
        }

        #main-content {
            flex-grow: 1;
            padding: var(--poster-gap);
            overflow-y: auto;
        }

        #poster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));
            gap: var(--poster-gap);
        }

        .poster {
            text-decoration: none;
            color: inherit;
            display: block;
            position: relative;
            background-color: #222;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 2 / 3;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 3px solid transparent;
        }

        .poster:focus {
            transform: scale(1.08);
            box-shadow: 0 0 20px rgba(0, 113, 235, 0.8);
            z-index: 10;
            border-color: var(--focus-color);
        }

        .poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .poster .rating {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        
        .poster .rating::before {
            content: 'â˜…';
            color: #ffc107;
            margin-right: 5px;
        }

        #scraper-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        .scraper-content {
            background-color: #1d1d1d;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
        }
        
        .scraper-content h2 {
            margin-top: 0;
        }

        #status-log {
            height: 300px;
            overflow-y: scroll;
            background-color: #101010;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            text-align: left;
            font-family: monospace;
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Ontdekken</h2>
        <nav id="main-nav">
            <a href="#" class="active" data-endpoint="/movie/popular">Populaire Films</a>
            <a href="#" data-endpoint="/movie/top_rated">Top Films</a>
            <a href="#" data-endpoint="/movie/now_playing">Nu in de Bioscoop</a>
            <a href="#" data-endpoint="/movie/upcoming">Verwachte Films</a>
            <a href="#" data-endpoint="/tv/popular">Populaire Series</a>
            <a href="#" data-endpoint="/tv/top_rated">Top Series</a>
        </nav>
        
        <div id="genre-list">
             <h2>Genres</h2>
             <nav id="movie-genres"></nav>
        </div>
    </div>

    <main id="main-content">
        <div id="poster-grid"></div>
    </main>

    <div id="scraper-overlay">
        <div class="scraper-content">
            <h2>TMDB API Sleutel Vereist</h2>
            <p>Er is geen API sleutel gevonden. We zoeken er nu automatisch een voor u...</p>
            <div id="status-log"></div>
        </div>
    </div>

    <script>
        const TMDB_API_KEY_STORAGE_KEY = 'tmdb_api_key';
        const BASE_IMAGE_URL = 'https://image.tmdb.org/t/p/w500';
        let apiKey = null;

        const mainNav = document.getElementById('main-nav');
        const genreNav = document.getElementById('movie-genres');
        const posterGrid = document.getElementById('poster-grid');
        const scraperOverlay = document.getElementById('scraper-overlay');
        const statusLog = document.getElementById('status-log');

        /**
         * The provided scraper function to find a working TMDB API key.
         */
        async function scrapeTmdbKeys(options = {}) {
            const {
                maxPages = 20,
                onStatusUpdate = (message) => console.log(message),
                onValidKeyFound = (apiKey, totalValidKeys) => {},
                proxyTimeout = 15000,
                apiKeyTestTimeout = 20000,
                maxConcurrentKeyTests = 5
            } = options;

            const BASE_URL = 'https://grep.app/search?regexp=true&q=%28tmdb.*%5Ba-f0-9%5D%7B32%7D%7C%5Ba-f0-9%5D%7B32%7D.*tmdb%29';
            const API_KEY_REGEX = /[a-f0-9]{32}/g;
            const PROXIES = [
                (url) => `https://api.codetabs.com/v1/proxy/?quest=${encodeURIComponent(url)}`,
                (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                (url) => `https://cors.eu.org/${url.replace(/^https?:\/\//, '')}`,
                (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            let foundPotentialKeys = new Set();
            let validApiKeys = [];
            let currentPage = 1;
            let selectedProxyDetails = null;

            async function determineFastestProxy(baseUrlForTest, proxyList, statusUpdateFn, timeout) {
                statusUpdateFn("Determining the fastest proxy...");
                const proxyPromises = proxyList.map(async (proxyBuilderFunc) => {
                    const proxyUrl = proxyBuilderFunc(baseUrlForTest);
                    const proxyNameMatch = proxyUrl.match(/https:\/\/([a-zA-Z0-9.-]+)/);
                    const proxyName = proxyNameMatch ? proxyNameMatch[1] : 'Unknown Proxy';
                    const startTime = Date.now();
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), timeout);
                        statusUpdateFn(`Testing proxy: ${proxyName}...`);
                        const response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        await response.text();
                        const duration = Date.now() - startTime;
                        statusUpdateFn(`OK: ${proxyName} responded in ${duration}ms.`);
                        return { proxyBuilder: proxyBuilderFunc, proxyName, duration, success: true };
                    } catch (error) {
                        statusUpdateFn(`FAIL: ${proxyName} (${error.name === 'AbortError' ? 'timeout' : error.message}).`);
                        return { duration: Infinity, success: false };
                    }
                });

                const results = await Promise.all(proxyPromises);
                const fastestProxy = results.filter(r => r.success).sort((a, b) => a.duration - b.toString())[0];

                if (fastestProxy) {
                    statusUpdateFn(`Fastest proxy selected: ${fastestProxy.proxyName}.`);
                    return { proxyBuilder: fastestProxy.proxyBuilder, proxyName: fastestProxy.proxyName };
                } else {
                    throw new Error("No working proxy found.");
                }
            }

            async function fetchWithSelectedProxy(url, pageNum, proxyDetails, statusUpdateFn, timeout) {
                const { proxyBuilder, proxyName } = proxyDetails;
                const proxyUrl = proxyBuilder(url);
                statusUpdateFn(`Page ${pageNum}: Fetching via ${proxyName}...`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.text();
                } catch (error) {
                    throw new Error(`Proxy fetch failed: ${error.message}`);
                }
            }

            async function testApiKeyValidity(apiKey, statusFn) {
                const shortKey = `${apiKey.substring(0, 8)}...`;
                statusFn(`Testing key: ${shortKey}`);
                const tmdbApiUrl = `https://api.themoviedb.org/3/configuration?api_key=${apiKey}`;
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), apiKeyTestTimeout);
                    const response = await fetch(tmdbApiUrl, { method: 'GET', signal: controller.signal });
                    clearTimeout(timeoutId);
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }

            async function processPage(pageNum, proxyDetails) {
                onStatusUpdate(`Fetching page ${pageNum}...`);
                const urlToFetch = `${BASE_URL}&page=${pageNum}`;
                try {
                    const html = await fetchWithSelectedProxy(urlToFetch, pageNum, proxyDetails, onStatusUpdate, proxyTimeout);
                    const keysOnPage = [...new Set(html.match(API_KEY_REGEX) || [])];
                    const newKeys = keysOnPage.filter(key => !foundPotentialKeys.has(key));

                    if (newKeys.length > 0) {
                        onStatusUpdate(`Page ${pageNum}: Found ${newKeys.length} new potential keys. Testing...`);
                        newKeys.forEach(key => foundPotentialKeys.add(key));

                        for (let i = 0; i < newKeys.length; i += maxConcurrentKeyTests) {
                            const batch = newKeys.slice(i, i + maxConcurrentKeyTests);
                            const testPromises = batch.map(key =>
                                testApiKeyValidity(key, onStatusUpdate).then(isValid => ({ key, isValid }))
                            );
                            const results = await Promise.all(testPromises);
                            results.forEach(result => {
                                if (result.isValid) {
                                    validApiKeys.push(result.key);
                                    onValidKeyFound(result.key, validApiKeys.length);
                                }
                            });
                        }
                    } else {
                        onStatusUpdate(`Page ${pageNum}: No new potential keys found.`);
                    }
                    return html.includes('Load More Results') || html.includes('loadMoreResults');
                } catch (error) {
                    onStatusUpdate(`Error on page ${pageNum}: ${error.message}. Stopping.`);
                    return false;
                }
            }

            onStatusUpdate("Starting process...");
            try {
                selectedProxyDetails = await determineFastestProxy(BASE_URL, PROXIES, onStatusUpdate, proxyTimeout);
            } catch (error) {
                onStatusUpdate(`Scraping aborted: ${error.message}`);
                return [];
            }

            let hasMore = true;
            while (hasMore && currentPage <= maxPages) {
                onStatusUpdate(`--- Processing Page ${currentPage}/${maxPages} ---`);
                hasMore = await processPage(currentPage, selectedProxyDetails);
                if (hasMore) currentPage++;
            }

            onStatusUpdate(`Scraping complete. Found ${validApiKeys.length} valid key(s).`);
            return validApiKeys;
        }

        /**
         * Fetches data from a TMDB endpoint.
         */
        async function fetchFromTmdb(endpoint, params = {}) {
            if (!apiKey) {
                console.error("TMDB API Key is not set.");
                return null;
            }
            const queryParams = new URLSearchParams({
                api_key: apiKey,
                language: 'nl-NL',
                ...params
            });
            const url = `https://api.themoviedb.org/3${endpoint}?${queryParams.toString()}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching from TMDB:", error);
                return null;
            }
        }

        /**
         * Renders a list of movies or series to the poster grid.
         */
        function renderContent(data) {
            posterGrid.innerHTML = '';
            if (!data || !data.results) return;

            data.results.forEach(item => {
                if (!item.poster_path) return; // Skip items without a poster

                const posterElement = document.createElement('a');
                posterElement.href = "#"; // For focusability
                posterElement.classList.add('poster');
                posterElement.setAttribute('aria-label', item.title || item.name);

                const img = document.createElement('img');
                img.src = `${BASE_IMAGE_URL}${item.poster_path}`;
                img.alt = item.title || item.name;
                img.loading = 'lazy';

                const rating = document.createElement('div');
                rating.classList.add('rating');
                rating.textContent = item.vote_average.toFixed(1);

                posterElement.appendChild(img);
                posterElement.appendChild(rating);
                posterGrid.appendChild(posterElement);
            });
        }

        /**
         * Loads content based on the selected navigation link.
         */
        async function loadContent(endpoint) {
            const data = await fetchFromTmdb(endpoint);
            renderContent(data);
        }
        
        async function loadContentByGenre(genreId) {
            const data = await fetchFromTmdb('/discover/movie', { with_genres: genreId });
            renderContent(data);
        }

        /**
         * Loads and populates the genre list in the sidebar.
         */
        async function loadGenres() {
            const data = await fetchFromTmdb('/genre/movie/list');
            if (!data || !data.genres) return;
            
            genreNav.innerHTML = '';
            data.genres.forEach(genre => {
                const link = document.createElement('a');
                link.href = "#";
                link.textContent = genre.name;
                link.dataset.genreId = genre.id;
                genreNav.appendChild(link);
            });
        }
        
        /**
         * Handles clicks on navigation items.
         */
        function handleNavClick(event, navElement) {
            event.preventDefault();
            const target = event.target.closest('a');
            if (!target) return;
            
            // Remove active class from all siblings
            navElement.querySelectorAll('a').forEach(a => a.classList.remove('active'));
            document.querySelectorAll('#main-nav a, #movie-genres a').forEach(a => a.classList.remove('active'));
            
            // Add active class to clicked link
            target.classList.add('active');
            
            if (target.dataset.endpoint) {
                loadContent(target.dataset.endpoint);
            } else if (target.dataset.genreId) {
                loadContentByGenre(target.dataset.genreId);
            }
        }

        /**
         * Application entry point.
         */
        async function main() {
            apiKey = localStorage.getItem(TMDB_API_KEY_STORAGE_KEY);

            if (!apiKey) {
                scraperOverlay.style.display = 'flex';
                let keyFound = false;

                const keys = await scrapeTmdbKeys({
                    onStatusUpdate: (message) => {
                        const p = document.createElement('p');
                        p.textContent = message;
                        statusLog.appendChild(p);
                        statusLog.scrollTop = statusLog.scrollHeight;
                    },
                    onValidKeyFound: (foundKey, total) => {
                        if (!keyFound) {
                            keyFound = true;
                            apiKey = foundKey;
                            localStorage.setItem(TMDB_API_KEY_STORAGE_KEY, apiKey);
                            
                            const p = document.createElement('p');
                            p.textContent = `SUCCESS: Valid key found! ${foundKey.substring(0,8)}... Loading content...`;
                            p.style.color = '#28a745';
                            p.style.fontWeight = 'bold';
                            statusLog.appendChild(p);
                            
                            setTimeout(() => {
                                scraperOverlay.style.display = 'none';
                                initializePage();
                            }, 2000);
                        }
                    }
                });

                if (!keyFound) {
                   const p = document.createElement('p');
                   p.textContent = `Scraping finished, but no valid key was found. Please try reloading the page.`;
                   p.style.color = '#dc3545';
                   p.style.fontWeight = 'bold';
                   statusLog.appendChild(p);
                }
            } else {
                initializePage();
            }
        }
        
        function initializePage() {
            mainNav.addEventListener('click', (e) => handleNavClick(e, mainNav));
            genreNav.addEventListener('click', (e) => handleNavClick(e, genreNav));
            
            loadGenres();
            // Load initial content
            const initialEndpoint = document.querySelector('#main-nav a.active').dataset.endpoint;
            loadContent(initialEndpoint);
        }

        window.onload = main;
    </script>
</body>
</html>