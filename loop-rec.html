<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>loop•rec</title>
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
<style>
:root {
--bg-color: #121212;
--primary-text-color: #e0e0e0;
--secondary-text-color: #b3b3b3;
--accent-color: #e53935;
--accent-hover-color: #f44336;
--surface-color: #1e1e1e;
--panel-color: #252525;
--modal-bg: rgba(0, 0, 0, 0.85);
--success-color: #4caf50;
--clip-color: #ff1744;
--telegram-color: #0088cc;
--warning-color: #ff9800;
}

html, body {
height: 100%;
margin: 0;
padding: 0;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
background-color: var(--bg-color);
color: var(--primary-text-color);
overflow: hidden;
}

.container {
display: flex;
flex-direction: column;
justify-content: flex-start;
align-items: center;
height: 100%;
padding: 40px 20px;
box-sizing: border-box;
gap: 30px;
position: relative;
z-index: 1;
}

.settings-btn {
position: absolute;
top: 20px;
right: 20px;
background: none;
border: none;
cursor: pointer;
color: var(--secondary-text-color);
padding: 10px;
transition: color 0.2s;
z-index: 10;
}

.settings-btn:hover {
color: var(--primary-text-color);
}

.settings-btn svg {
width: 24px;
height: 24px;
fill: currentColor;
}

.header {
text-align: center;
position: relative;
width: 100%;
max-width: 600px;
margin-top: 20px;
}

h1 {
margin: 0;
font-size: 3.2em;
color: var(--primary-text-color);
font-weight: bold;
letter-spacing: -1px;
}

.dot {
color: var(--accent-color);
animation: blink 1.2s infinite;
margin: 0 0.1em;
display: inline-block;
transform: translateY(0.1em);
}

@keyframes blink {
0%, 100% { opacity: 1; }
50% { opacity: 0; }
}

#status {
color: var(--secondary-text-color);
margin: 5px 0 0 0;
height: auto;
min-height: 1.2em;
font-size: 0.9em;
transition: opacity 0.5s ease;
opacity: 1;
}

#status.fade-out {
opacity: 0;
}

.visualizer-container {
width: 100%;
height: 200px;
max-height: 250px;
display: flex;
align-items: center;
justify-content: center;
min-height: 150px;
padding: 0;
position: relative;
}

#visualizer {
width: 100%;
height: 100%;
background-color: var(--surface-color);
border-radius: 8px;
}

.controls {
width: 100%;
display: flex;
flex-direction: column;
align-items: center;
gap: 15px;
}

#saveButton {
background-color: var(--accent-color);
color: white;
border: none;
border-radius: 50px;
padding: 15px 30px;
font-size: 1.2em;
font-weight: bold;
cursor: pointer;
transition: background-color 0.2s, transform 0.1s;
width: 100%;
max-width: 300px;
position: relative;
overflow: hidden;
}

#saveButton:hover {
background-color: var(--accent-hover-color);
}

#saveButton:active {
transform: scale(0.98);
}

#saveButton:disabled {
background-color: #535353;
cursor: not-allowed;
}

.modal-overlay {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--modal-bg);
z-index: 100;
justify-content: center;
align-items: center;
backdrop-filter: blur(5px);
}

.modal-overlay.active {
display: flex;
}

.modal-content {
background-color: var(--surface-color);
padding: 30px;
border-radius: 12px;
width: 90%;
max-width: 400px;
max-height: 85vh;
overflow-y: auto;
box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}

.modal-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
}

.modal-header h2 {
margin: 0;
font-size: 1.5em;
}

.close-btn {
background: none;
border: none;
color: var(--secondary-text-color);
font-size: 1.5em;
cursor: pointer;
}

.setting-group {
margin-bottom: 20px;
}

.setting-group label {
display: block;
margin-bottom: 8px;
color: var(--secondary-text-color);
font-size: 0.9em;
}

.setting-group select,
.setting-group input[type="range"],
.setting-group input[type="text"],
.setting-group input[type="password"] {
width: 100%;
background-color: var(--bg-color);
color: var(--primary-text-color);
border: 1px solid #444;
border-radius: 6px;
padding: 10px;
font-size: 1em;
box-sizing: border-box;
}

.setting-group input[type="text"]:focus,
.setting-group input[type="password"]:focus {
border-color: var(--accent-color);
outline: none;
}

.setting-group input[type="range"] {
padding: 0;
height: 4px;
margin: 15px 0;
-webkit-appearance: none;
background: #444;
}

.setting-group input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
width: 20px;
height: 20px;
background: var(--accent-color);
border-radius: 50%;
cursor: pointer;
}

.range-value {
float: right;
color: var(--primary-text-color);
}

.hidden {
display: none;
}

/* Telegram Card */
.telegram-card {
background-color: var(--panel-color);
border-radius: 8px;
margin-bottom: 20px;
overflow: hidden;
border: 1px solid #333;
}

.telegram-header {
display: flex;
justify-content: space-between;
align-items: center;
padding: 15px;
cursor: pointer;
background-color: rgba(255,255,255,0.03);
}

.telegram-header:hover {
background-color: rgba(255,255,255,0.06);
}

.tg-status-group {
display: flex;
align-items: center;
gap: 10px;
}

.status-led {
width: 10px;
height: 10px;
border-radius: 50%;
background-color: #555;
transition: background-color 0.3s, box-shadow 0.3s;
}

.status-led.connected { background-color: var(--success-color); box-shadow: 0 0 6px var(--success-color); }
.status-led.connecting { background-color: var(--warning-color); }
.status-led.error { background-color: var(--clip-color); }

.tg-label {
font-weight: 500;
color: var(--primary-text-color);
}

.tg-sub {
font-size: 0.8em;
color: var(--secondary-text-color);
margin-left: 5px;
}

.tg-toggle-icon {
color: var(--secondary-text-color);
transition: transform 0.3s;
}

.tg-toggle-icon.rotated {
transform: rotate(90deg);
}

.telegram-inputs {
padding: 0 15px 15px 15px;
border-top: 1px solid #333;
animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
from { opacity: 0; transform: translateY(-10px); }
to { opacity: 1; transform: translateY(0); }
}

.telegram-note {
font-size: 0.8em;
color: #777;
margin-top: 8px;
line-height: 1.4;
}

/* Standalone Generator Styles */
.settings-divider {
border: 0;
border-top: 1px solid #333;
margin: 30px 0 20px 0;
}

#downloadStandaloneButton {
background-color: transparent;
color: var(--secondary-text-color);
border: 1px solid var(--secondary-text-color);
border-radius: 6px;
padding: 12px 20px;
font-size: 0.9em;
cursor: pointer;
transition: background-color 0.2s, color 0.2s;
width: 100%;
display: block;
}

#downloadStandaloneButton:hover {
background-color: var(--secondary-text-color);
color: var(--bg-color);
}

#downloadStandaloneButton:disabled {
opacity: 0.5;
cursor: not-allowed;
}

.flash-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--success-color);
opacity: 0;
pointer-events: none;
z-index: 200;
transition: opacity 0.5s ease-out;
}

.flash-overlay.flash {
opacity: 0.3;
transition: none;
}

.flash-overlay.telegram-success {
background-color: var(--telegram-color);
}
</style>
</head>
<body>

<div class="flash-overlay" id="flashOverlay"></div>

<div class="container">
<button id="settingsBtn" class="settings-btn" title="Settings">
<svg viewBox="0 0 24 24">
<path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
</svg>
</button>

<div class="header">
<h1>loop<span class="dot">•</span>rec</h1>
<p id="status"></p>
</div>

<div class="visualizer-container">
<canvas id="visualizer"></canvas>
</div>

<div class="controls">
<button id="saveButton" disabled>Initializing...</button>
</div>
</div>

<div class="modal-overlay" id="settingsModal">
<div class="modal-content">
<div class="modal-header">
<h2>Settings</h2>
<button class="close-btn" id="closeSettings">&times;</button>
</div>

<div class="setting-group">
<label for="micSelect">Input Source</label>
<select id="micSelect"></select>
</div>

<div class="setting-group">
<label for="channelSelect">Channel Mode</label>
<select id="channelSelect">
<option value="ch1">Mono (Channel 1 / Left)</option>
<option value="ch2">Mono (Channel 2 / Right)</option>
<option value="stereo" selected>True Stereo (Raw)</option>
</select>
</div>

<div class="setting-group">
<label for="saveModeSelect">Save Mode</label>
<select id="saveModeSelect">
<option value="local" selected>Local Download</option>
<option value="telegram">Upload to Telegram</option>
<option value="both">Local + Telegram</option>
</select>
</div>

<!-- Telegram Card (Compact UI) -->
<div class="telegram-card">
<div class="telegram-header" id="tgHeader">
<div class="tg-status-group">
<div class="status-led" id="tgStatusLed"></div>
<div>
<span class="tg-label">Telegram</span>
<span class="tg-sub" id="tgStatusText">Disconnected</span>
</div>
</div>
<div class="tg-toggle-icon" id="tgToggleIcon">
<!-- Gear Icon -->
<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
<path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
</svg>
</div>
</div>

<div id="tgInputs" class="telegram-inputs hidden">
<div class="setting-group" style="margin-top: 15px;">
<label for="telegramToken">Bot Token</label>
<input type="password" id="telegramToken" placeholder="123456:ABC-DEF1234ghIkl...">
</div>
<div class="setting-group">
<label for="telegramChatId">Chat ID / @channel</label>
<input type="text" id="telegramChatId" placeholder="-100123456... or @name">
<p class="telegram-note">
Bot must be member/admin. Triggers via <b>/save</b> in Channel or DM.
</p>
</div>
</div>
</div>

<div class="setting-group">
<label for="bitrateSelect">Quality (Bitrate)</label>
<select id="bitrateSelect">
<option value="128">128 kbps (Standard)</option>
<option value="192" selected>192 kbps (High)</option>
<option value="256">256 kbps (Very High)</option>
<option value="320">320 kbps (Maximum)</option>
</select>
</div>

<div class="setting-group">
<label for="bufferRange">
Memory Buffer <span class="range-value" id="bufferValue">5 min</span>
</label>
<input type="range" id="bufferRange" min="1" max="20" value="5" step="1">
</div>

<div id="standalone-container">
<hr class="settings-divider">
<button id="downloadStandaloneButton">Download Standalone Version</button>
</div>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
const statusEl = document.getElementById('status');
const saveButton = document.getElementById('saveButton');
const canvas = document.getElementById('visualizer');
const canvasCtx = canvas.getContext('2d');

const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const closeSettingsBtn = document.getElementById('closeSettings');

// Settings Elements
const micSelect = document.getElementById('micSelect');
const channelSelect = document.getElementById('channelSelect');
const bitrateSelect = document.getElementById('bitrateSelect');
const bufferRange = document.getElementById('bufferRange');
const bufferValue = document.getElementById('bufferValue');
const saveModeSelect = document.getElementById('saveModeSelect');

// Telegram Elements
const tgHeader = document.getElementById('tgHeader');
const tgInputs = document.getElementById('tgInputs');
const tgToggleIcon = document.getElementById('tgToggleIcon');
const telegramTokenInput = document.getElementById('telegramToken');
const telegramChatIdInput = document.getElementById('telegramChatId');
const tgStatusLed = document.getElementById('tgStatusLed');
const tgStatusText = document.getElementById('tgStatusText');

const flashOverlay = document.getElementById('flashOverlay');

let audioContext;
let mediaStream;
let sourceNode;
let workletNode;
let recordingStartTime;
let buttonUpdateInterval;
let pruneInterval;
let soundAudioCtx;
let gainNode;

// Default config
let config = {
bufferMinutes: 5,
bitrate: 192,
deviceId: 'default',
channelMode: 'stereo',
saveMode: 'local',
telegramToken: '',
telegramChatId: ''
};

let mp3Encoder;
let mp3Chunks = [];

let visualizationData = [];
let maxVisualPoints;
const WORKLET_BUFFER_SIZE = 128;
const VISUAL_DOWNSAMPLE_RATE = 25;
let accumulatedMax = 0;
let accumulateCount = 0;
let isClipping = false;
let clipTimer = null;
let statusTimer = null;

// Telegram Remote Control Vars
let telegramPollingActive = false;
let lastUpdateId = 0;
let pollingAbortController = null;
let tgDebounceTimer = null;

// Load settings
function loadSettings() {
const saved = localStorage.getItem('looprec_settings');
if (saved) {
try {
const parsed = JSON.parse(saved);
config = { ...config, ...parsed };
bufferRange.value = config.bufferMinutes;
bufferValue.textContent = `${config.bufferMinutes} min`;
if (config.bitrate) bitrateSelect.value = config.bitrate;
if (config.saveMode) saveModeSelect.value = config.saveMode;
if (config.channelMode) channelSelect.value = config.channelMode;
if (config.telegramToken) telegramTokenInput.value = config.telegramToken;
if (config.telegramChatId) telegramChatIdInput.value = config.telegramChatId;

// Auto-expand inputs ONLY if credentials exist but are maybe partial, or if user left them open last time (optional)
// But typically, we keep them closed unless necessary.
// If credentials exist, start polling
if (config.telegramToken && config.telegramChatId) {
startTelegramPolling();
}

} catch (e) {
console.error("Failed to load settings", e);
}
}
// If no settings (fresh run), we do NOT auto-open telegram inputs or modal
}

function saveSettings() {
// Just save to local storage, do NOT interrupt polling
localStorage.setItem('looprec_settings', JSON.stringify(config));
}

function saveAndRestartTelegram() {
saveSettings();
// Debounce the restart so we don't hammer the API while typing
if (tgDebounceTimer) clearTimeout(tgDebounceTimer);
tgDebounceTimer = setTimeout(() => {
startTelegramPolling();
}, 1000);
}

function showStatus(message, duration = 0) {
if (statusTimer) clearTimeout(statusTimer);
statusEl.classList.remove('fade-out');
statusEl.textContent = message;

if (duration > 0) {
statusTimer = setTimeout(() => {
statusEl.classList.add('fade-out');
}, duration);
}
}

document.addEventListener('keydown', (event) => {
if (event.key === 'PageDown') {
event.preventDefault();
if (!saveButton.disabled) saveButton.click();
}
});

const resumeAudio = () => {
if (audioContext && audioContext.state === 'suspended') {
audioContext.resume();
}
};
document.addEventListener('click', resumeAudio);
document.addEventListener('keydown', resumeAudio);

settingsBtn.addEventListener('click', () => {
settingsModal.classList.add('active');
populateDeviceList();
});

closeSettingsBtn.addEventListener('click', () => {
settingsModal.classList.remove('active');
});

settingsModal.addEventListener('click', (e) => {
if (e.target === settingsModal) settingsModal.classList.remove('active');
});

micSelect.addEventListener('change', async () => {
config.deviceId = micSelect.value;
saveSettings();
await initAudio();
});

channelSelect.addEventListener('change', async () => {
config.channelMode = channelSelect.value;
saveSettings();
await initAudio();
});

bitrateSelect.addEventListener('change', () => {
config.bitrate = parseInt(bitrateSelect.value);
saveSettings();
showStatus('Bitrate changed. Buffer reset.', 3000);
resetRecordingState();
});

// IMPORTANT: Only save settings here, DO NOT restart polling
bufferRange.addEventListener('input', () => {
config.bufferMinutes = parseInt(bufferRange.value);
saveSettings();
bufferValue.textContent = `${config.bufferMinutes} min`;
updateButtonText();
recalcMaxVisualPoints();
});

saveModeSelect.addEventListener('change', () => {
config.saveMode = saveModeSelect.value;
saveSettings();
});

// Toggle Telegram Inputs
tgHeader.addEventListener('click', () => {
tgInputs.classList.toggle('hidden');
tgToggleIcon.classList.toggle('rotated');
});

// Inputs update settings AND trigger a delayed restart
telegramTokenInput.addEventListener('input', () => {
config.telegramToken = telegramTokenInput.value.trim();
saveAndRestartTelegram();
});

telegramChatIdInput.addEventListener('input', () => {
config.telegramChatId = telegramChatIdInput.value.trim();
saveAndRestartTelegram();
});

function resizeCanvas() {
const container = document.querySelector('.visualizer-container');
canvas.width = container.offsetWidth;
canvas.height = container.offsetHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function recalcMaxVisualPoints() {
if (!audioContext) return;
const pointsPerSecond = (audioContext.sampleRate / WORKLET_BUFFER_SIZE) / VISUAL_DOWNSAMPLE_RATE;
maxVisualPoints = Math.ceil(pointsPerSecond * (config.bufferMinutes * 60));
}

async function populateDeviceList() {
try {
const devices = await navigator.mediaDevices.enumerateDevices();
const audioInputs = devices.filter(device => device.kind === 'audioinput');
const currentSelection = config.deviceId;
micSelect.innerHTML = '';
audioInputs.forEach(device => {
const option = document.createElement('option');
option.value = device.deviceId;
option.text = device.label || `Microphone ${micSelect.length + 1}`;
micSelect.appendChild(option);
});
if (Array.from(micSelect.options).some(opt => opt.value === currentSelection)) {
micSelect.value = currentSelection;
}
} catch (err) {
console.error('Error enumerating devices:', err);
}
}

async function initAudio() {
showStatus('Requesting audio access...');
saveButton.disabled = true;

try {
if (mediaStream) {
mediaStream.getTracks().forEach(track => track.stop());
}

const constraints = {
audio: {
deviceId: config.deviceId && config.deviceId !== 'default' ? { exact: config.deviceId } : undefined,
echoCancellation: false,
noiseSuppression: false,
autoGainControl: false,
channelCount: 2
}
};

mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
const track = mediaStream.getAudioTracks()[0];
const settings = track.getSettings();

if (!audioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
const workletCode = `
class RecorderProcessor extends AudioWorkletProcessor {
process(inputs, outputs, parameters) {
const input = inputs[0];
if (input && input.length > 0) {
const channels = [];
for(let i = 0; i < input.length; i++) {
channels.push(input[i].slice());
}
this.port.postMessage(channels);
}
return true;
}
}
registerProcessor('recorder-processor', RecorderProcessor);
`;
const workletBlob = new Blob([workletCode], { type: 'application/javascript' });
const workletUrl = URL.createObjectURL(workletBlob);
await audioContext.audioWorklet.addModule(workletUrl);
}

if (audioContext.state === 'suspended') await audioContext.resume();

if (sourceNode) sourceNode.disconnect();
if (workletNode) workletNode.disconnect();

sourceNode = audioContext.createMediaStreamSource(mediaStream);

workletNode = new AudioWorkletNode(audioContext, 'recorder-processor', {
numberOfInputs: 1,
numberOfOutputs: 1,
outputChannelCount: [2],
channelCount: 2,
channelCountMode: 'explicit'
});

if (!gainNode) {
gainNode = audioContext.createGain();
gainNode.gain.value = 0;
gainNode.connect(audioContext.destination);
}

const isStereo = config.channelMode === 'stereo';
mp3Encoder = new lamejs.Mp3Encoder(isStereo ? 2 : 1, audioContext.sampleRate, config.bitrate);
recalcMaxVisualPoints();

workletNode.port.onmessage = (event) => {
const channels = event.data;
if (!channels || channels.length === 0) return;

let dataToEncodeL, dataToEncodeR;
let visualData;

if (config.channelMode === 'stereo') {
if (channels.length >= 2) {
dataToEncodeL = channels[0];
dataToEncodeR = channels[1];
} else {
dataToEncodeL = channels[0];
dataToEncodeR = channels[0];
}
visualData = new Float32Array(dataToEncodeL.length);
for(let i=0; i<dataToEncodeL.length; i++) {
visualData[i] = (dataToEncodeL[i] + dataToEncodeR[i]) / 2;
}
} else if (config.channelMode === 'ch2') {
visualData = (channels.length > 1) ? channels[1] : channels[0];
dataToEncodeL = visualData;
} else {
visualData = channels[0];
dataToEncodeL = visualData;
}

let localMax = 0;
for (let i = 0; i < visualData.length; i++) {
const abs = Math.abs(visualData[i]);
if (abs > localMax) localMax = abs;
}

if (localMax > 0.95) {
isClipping = true;
if(clipTimer) clearTimeout(clipTimer);
clipTimer = setTimeout(() => { isClipping = false; }, 300);
}

if (localMax > accumulatedMax) accumulatedMax = localMax;
accumulateCount++;

if (accumulateCount >= VISUAL_DOWNSAMPLE_RATE) {
visualizationData.push(accumulatedMax);
accumulatedMax = 0;
accumulateCount = 0;
if (visualizationData.length > maxVisualPoints) visualizationData.shift();
}

let mp3buf;
const pcmLeft = convertFloat32ToInt16(dataToEncodeL);

if (config.channelMode === 'stereo') {
const pcmRight = convertFloat32ToInt16(dataToEncodeR);
mp3buf = mp3Encoder.encodeBuffer(pcmLeft, pcmRight);
} else {
mp3buf = mp3Encoder.encodeBuffer(pcmLeft);
}

if (mp3buf.length > 0) {
mp3Chunks.push({ data: mp3buf, timestamp: Date.now() });
}
};

sourceNode.connect(workletNode);
workletNode.connect(gainNode);

const inputChannels = settings.channelCount || 2;
showStatus(`Ready (Rec: ${inputChannels}ch source)`, 3000);
saveButton.disabled = false;

resetRecordingState();
populateDeviceList();

} catch (err) {
showStatus(`Error: ${err.message}`);
console.error("Init Error:", err);
}
}

function resetRecordingState() {
mp3Chunks = [];
visualizationData = [];
accumulatedMax = 0;
accumulateCount = 0;
recordingStartTime = Date.now();

if (audioContext) {
const isStereo = config.channelMode === 'stereo';
mp3Encoder = new lamejs.Mp3Encoder(isStereo ? 2 : 1, audioContext.sampleRate, config.bitrate);
}

if (buttonUpdateInterval) clearInterval(buttonUpdateInterval);
buttonUpdateInterval = setInterval(updateButtonText, 1000);

if (pruneInterval) clearInterval(pruneInterval);
pruneInterval = setInterval(pruneChunks, 5000);
}

function pruneChunks() {
if (mp3Chunks.length === 0) return;
const bufferMs = config.bufferMinutes * 60 * 1000;
const cutoffTime = Date.now() - bufferMs - 10000;
let spliceIndex = -1;
for(let i=0; i<mp3Chunks.length; i++) {
if (mp3Chunks[i].timestamp < cutoffTime) spliceIndex = i;
else break;
}
if (spliceIndex > -1) mp3Chunks.splice(0, spliceIndex + 1);
}

function playSaveSound() {
if (!soundAudioCtx) soundAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
if (soundAudioCtx.state === 'suspended') soundAudioCtx.resume();
const now = soundAudioCtx.currentTime;
const osc1 = soundAudioCtx.createOscillator();
const gain1 = soundAudioCtx.createGain();
osc1.connect(gain1);
gain1.connect(soundAudioCtx.destination);
osc1.type = 'sine';
osc1.frequency.setValueAtTime(523.25, now);
gain1.gain.setValueAtTime(0, now);
gain1.gain.linearRampToValueAtTime(0.4, now + 0.01);
gain1.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
osc1.start(now);
osc1.stop(now + 0.15);
const osc2 = soundAudioCtx.createOscillator();
const gain2 = soundAudioCtx.createGain();
osc2.connect(gain2);
gain2.connect(soundAudioCtx.destination);
osc2.type = 'sine';
osc2.frequency.setValueAtTime(783.99, now);
gain2.gain.setValueAtTime(0, now + 0.1);
gain2.gain.linearRampToValueAtTime(0.4, now + 0.11);
gain2.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
osc2.start(now + 0.1);
osc2.stop(now + 0.3);
flashOverlay.className = 'flash-overlay flash';
if(config.saveMode === 'telegram') flashOverlay.classList.add('telegram-success');
setTimeout(() => { flashOverlay.className = 'flash-overlay'; }, 500);
}

function convertFloat32ToInt16(buffer) {
let l = buffer.length;
const buf = new Int16Array(l);
while (l--) {
buf[l] = Math.min(1, Math.max(-1, buffer[l])) * 0x7FFF;
}
return buf;
}

let animationFrameId;
function drawWaveform() {
animationFrameId = requestAnimationFrame(drawWaveform);
canvasCtx.fillStyle = '#1e1e1e';
canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
if (isClipping) {
canvasCtx.fillStyle = 'rgba(255, 23, 68, 0.2)';
canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
canvasCtx.strokeStyle = '#ff1744';
} else {
canvasCtx.strokeStyle = '#b3b3b3';
}
canvasCtx.lineWidth = 2;
canvasCtx.beginPath();
const currentDataLength = visualizationData.length;
const scale = Math.min(currentDataLength, maxVisualPoints || 1000);
const sliceWidth = canvas.width / scale;
let x = 0;
const startPoint = Math.max(0, currentDataLength - (maxVisualPoints || 1000));
for (let i = 0; i < scale; i++) {
const item = visualizationData[startPoint + i];
const v = Math.min(canvas.height, item * canvas.height * 2);
const y = (canvas.height - v) / 2;
canvasCtx.moveTo(x, y);
canvasCtx.lineTo(x, y + v);
x += sliceWidth;
}
canvasCtx.stroke();
}

function updateButtonText() {
if (!recordingStartTime) return;
const elapsedMs = Date.now() - recordingStartTime;
const bufferMs = config.bufferMinutes * 60 * 1000;
let actionText = "Save";
if (config.saveMode === 'telegram') actionText = "Upload";
if (config.saveMode === 'both') actionText = "Save & Upload";
if (elapsedMs >= bufferMs) {
saveButton.textContent = `${actionText} last ${config.bufferMinutes} minutes`;
} else {
const elapsedSeconds = Math.floor(elapsedMs / 1000);
const minutes = Math.floor(elapsedSeconds / 60);
const seconds = elapsedSeconds % 60;
const formattedTime = `${minutes}:${String(seconds).padStart(2, '0')}`;
saveButton.textContent = `${actionText} (${formattedTime})`;
}
}

async function saveRecordedAudio() {
if (mp3Chunks.length === 0) {
showStatus('No audio recorded yet.', 3000);
return;
}
const needsTelegram = config.saveMode === 'telegram' || config.saveMode === 'both';

// Only check for credentials if we ACTUALLY need Telegram
if (needsTelegram && (!config.telegramToken || !config.telegramChatId)) {
showStatus('Missing Telegram Token or Chat ID.', 3000);
settingsModal.classList.add('active');
tgInputs.classList.remove('hidden');
tgToggleIcon.classList.add('rotated');
return;
}

playSaveSound();
saveButton.disabled = true;
const originalText = saveButton.textContent;
saveButton.textContent = 'Processing...';

const chunksToSave = [...mp3Chunks];
const finalBufferToSave = mp3Encoder.flush();
if (finalBufferToSave.length > 0) chunksToSave.push({ data: finalBufferToSave, timestamp: Date.now() });
const saveInitiationTime = Date.now();

// Reset
const isStereo = config.channelMode === 'stereo';
mp3Encoder = new lamejs.Mp3Encoder(isStereo ? 2 : 1, audioContext.sampleRate, config.bitrate);
mp3Chunks = [];
visualizationData = [];
recordingStartTime = Date.now();
updateButtonText();

setTimeout(async () => {
const bufferMs = config.bufferMinutes * 60 * 1000;
const relevantMp3Data = chunksToSave.filter(chunk => saveInitiationTime - chunk.timestamp <= bufferMs).map(chunk => chunk.data);
if (relevantMp3Data.length === 0) {
showStatus('No recent audio.', 3000);
saveButton.disabled = false;
saveButton.textContent = originalText;
return;
}
const mp3Blob = new Blob(relevantMp3Data, { type: 'audio/mpeg' });
const today = new Date();
const filename = `loop•rec-[${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}]-${config.channelMode}.mp3`;

try {
if (config.saveMode === 'local' || config.saveMode === 'both') downloadMp3(mp3Blob, filename);
if (config.saveMode === 'telegram' || config.saveMode === 'both') {
saveButton.textContent = 'Uploading...';
await uploadToTelegram(mp3Blob, filename);
}
showStatus('Done!', 3000);
saveButton.textContent = 'Saved!';
} catch (e) {
console.error(e);
showStatus('Error: ' + e.message);
saveButton.textContent = 'Error';
} finally {
setTimeout(() => {
saveButton.disabled = false;
updateButtonText();
}, 2000);
}
}, 50);
}

function downloadMp3(mp3Blob, filename) {
const url = URL.createObjectURL(mp3Blob);
const a = document.createElement('a');
a.style.display = 'none';
a.href = url;
a.download = filename;
document.body.appendChild(a);
a.click();
setTimeout(() => {
document.body.removeChild(a);
window.URL.revokeObjectURL(url);
}, 1500);
}

async function uploadToTelegram(blob, filename) {
const formData = new FormData();
let chatId = config.telegramChatId.trim();
if (!chatId.startsWith('@') && !chatId.startsWith('-') && /^\d+$/.test(chatId)) chatId = '-100' + chatId;
formData.append('chat_id', chatId);
formData.append('audio', blob, filename);
const url = `https://api.telegram.org/bot${config.telegramToken}/sendAudio`;
const response = await fetch(url, { method: 'POST', body: formData });
const result = await response.json();
if (!result.ok) throw new Error(result.description || 'Telegram Upload Failed');
return result;
}

/* --- Telegram Long Polling Logic --- */

function updateTgStatusUI(state) {
tgStatusLed.className = 'status-led';
if (state === 'connected') {
tgStatusLed.classList.add('connected');
tgStatusText.textContent = 'Connected';
} else if (state === 'connecting') {
tgStatusLed.classList.add('connecting');
tgStatusText.textContent = 'Connecting...';
} else {
tgStatusLed.classList.add('error');
tgStatusText.textContent = 'Disconnected';
}
}

function stopTelegramPolling() {
telegramPollingActive = false;
if (pollingAbortController) {
pollingAbortController.abort();
pollingAbortController = null;
}
updateTgStatusUI('disconnected');
}

function startTelegramPolling() {
stopTelegramPolling(); // Reset existing
// If no credentials, stay disconnected
if (!config.telegramToken || !config.telegramChatId) {
updateTgStatusUI('disconnected');
return;
}
telegramPollingActive = true;
updateTgStatusUI('connecting');
processTelegramUpdates();
}

async function processTelegramUpdates() {
let offset = lastUpdateId + 1;
while (telegramPollingActive) {
try {
pollingAbortController = new AbortController();
const url = `https://api.telegram.org/bot${config.telegramToken}/getUpdates?offset=${offset}&timeout=30&allowed_updates=["message","channel_post"]`;

const response = await fetch(url, { signal: pollingAbortController.signal });
if (!response.ok) {
if (response.status === 401 || response.status === 404) {
updateTgStatusUI('error');
telegramPollingActive = false;
showStatus("Telegram Token Invalid");
return;
}
await new Promise(r => setTimeout(r, 5000));
continue;
}

const data = await response.json();
if (data.ok) {
updateTgStatusUI('connected');
for (const update of data.result) {
lastUpdateId = update.update_id;
offset = lastUpdateId + 1;

const msg = update.message || update.channel_post;
if (!msg || !msg.text) continue;

let isAllowed = false;
let targetChatId = config.telegramChatId.trim();
if (!targetChatId.startsWith('@') && !targetChatId.startsWith('-') && /^\d+$/.test(targetChatId)) {
targetChatId = '-100' + targetChatId;
}

const senderId = String(msg.chat.id);
if (targetChatId.startsWith('@')) {
if(msg.chat.username && '@' + msg.chat.username === targetChatId) isAllowed = true;
} else {
if (senderId === targetChatId) isAllowed = true;
}

if (!isAllowed && msg.chat.type === 'private') {
isAllowed = await checkMembership(targetChatId, msg.from.id);
}

if (isAllowed) {
const text = msg.text.trim().toLowerCase();
if (text === '/save' || text === 'save') {
if (!saveButton.disabled) {
showStatus("Remote Trigger Received!");
saveRecordedAudio();
}
}
}
}
}
} catch (e) {
if (e.name === 'AbortError') return;
console.warn("Polling error", e);
updateTgStatusUI('connecting');
await new Promise(r => setTimeout(r, 5000));
}
}
}

async function checkMembership(chatId, userId) {
try {
const url = `https://api.telegram.org/bot${config.telegramToken}/getChatMember?chat_id=${chatId}&user_id=${userId}`;
const response = await fetch(url);
const data = await response.json();
if (!data.ok) return false;
const status = data.result.status;
return ['creator', 'administrator', 'member'].includes(status);
} catch (e) {
console.error("Error checking membership", e);
return false;
}
}

saveButton.addEventListener('click', saveRecordedAudio);

// Initialize
loadSettings();
drawWaveform();
initAudio();

// --- Standalone Download Logic ---
const downloadStandaloneButton = document.getElementById('downloadStandaloneButton');
if (downloadStandaloneButton) {
downloadStandaloneButton.addEventListener('click', async () => {
const button = downloadStandaloneButton;
const originalText = 'Download Standalone Version';
button.textContent = 'Preparing...';
button.disabled = true;
try {
const lameJsResponse = await fetch('https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js');
if (!lameJsResponse.ok) throw new Error('Failed to fetch lame.min.js');
const lameJsCode = await lameJsResponse.text();

// We get the outerHTML, but we MUST sanitize it to mimic the original untouched code
// because the current DOM might have classes like 'active', 'fade-out' or changed text.
let htmlContent = document.documentElement.outerHTML;

// 1. Inject the library
const scriptTagToReplace = '<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"><\/script>';
const inlineScriptTag = `<script>${lameJsCode}<\/script>`;
htmlContent = htmlContent.replace(scriptTagToReplace, inlineScriptTag);

// 2. Remove the Standalone Button container
htmlContent = htmlContent.replace(/<div id="standalone-container">[\s\S]*?<\/div>/, '');

// 3. Remove the Standalone Logic Script
const logicToRemoveRegex = /\/\/ --- Standalone Download Logic ---[\s\S]*?\/\/ --- End Standalone Download Logic ---/m;
htmlContent = htmlContent.replace(logicToRemoveRegex, '');

// 4. SANITIZE DOM STATE to restore "Original/Default" state
// Reset Modal (remove 'active')
htmlContent = htmlContent.replace(/class="modal-overlay active"/g, 'class="modal-overlay"');
// Reset Telegram Inputs (ensure 'hidden' is present)
htmlContent = htmlContent.replace(/id="tgInputs" class="telegram-inputs"/g, 'id="tgInputs" class="telegram-inputs hidden"');
// Reset Telegram Icon Rotation
htmlContent = htmlContent.replace(/id="tgToggleIcon" class="tg-toggle-icon rotated"/g, 'id="tgToggleIcon" class="tg-toggle-icon"');
// Reset Status Text
htmlContent = htmlContent.replace(/<p id="status"[^>]*>.*?<\/p>/, '<p id="status"></p>');
// Reset Save Button State and Text
htmlContent = htmlContent.replace(/<button id="saveButton"[^>]*>.*?<\/button>/, '<button id="saveButton" disabled>Initializing...</button>');
// Reset Telegram Status Text and LED
htmlContent = htmlContent.replace(/id="tgStatusText">.*?<\/span>/, 'id="tgStatusText">Disconnected</span>');
htmlContent = htmlContent.replace(/id="tgStatusLed" class="status-led.*?"/, 'id="tgStatusLed" class="status-led"');
// Reset Visualizer Canvas (it creates inline width/height that we don't strictly need in source)
htmlContent = htmlContent.replace(/<canvas id="visualizer" width=".*?" height=".*?"><\/canvas>/, '<canvas id="visualizer"></canvas>');

const blob = new Blob([htmlContent], { type: 'text/html' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'loop-rec-standalone.html';
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
window.URL.revokeObjectURL(url);
button.textContent = 'Downloaded!';
setTimeout(() => {
button.textContent = originalText;
button.disabled = false;
}, 2000);
} catch (error) {
console.error('Error creating standalone version:', error);
button.textContent = 'Error! Try again.';
setTimeout(() => {
button.textContent = originalText;
button.disabled = false;
}, 3000);
}
});
}
// --- End Standalone Download Logic ---
});
</script>
</body>
</html>