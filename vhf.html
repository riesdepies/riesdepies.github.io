<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Valkhof Festival 2025</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<style>
body {
font-family: Arial, sans-serif;
margin: 0;
padding: 10px;
background: #f0f0f0;
}
.tab-container {
display: grid;
grid-template-columns: repeat(7, 1fr);
gap: 5px;
margin-bottom: 10px;
}
.tab {
padding: 10px;
font-size: 14px;
text-align: center;
background: #ddd;
border: none;
cursor: pointer;
border-radius: 4px;
}
.tab.active {
background: #007bff;
color: #fff;
}
.filter-container {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 5px;
margin-bottom: 10px;
}
.filter-button, #searchField {
padding: 10px;
font-size: 14px;
text-align: center;
background: #fff;
border: 1px solid #ddd;
border-radius: 20px;
cursor: pointer;
box-sizing: border-box;
}
.filter-button.active {
background: #007bff;
color: #fff;
}
#searchField {
width: 100%;
}
#searchField:focus {
outline: none;
border-color: #007bff;
}
#searchField.has-content {
background: #007bff;
color: #fff;
}
.info-container {
background: #fff;
border-radius: 4px;
padding: 15px;
margin-bottom: 10px;
display: flex;
align-items: center;
box-shadow: 0 1px 3px rgba(0,0,0,0.1);
/* Hoogte wordt nu impliciet bepaald door content, maar zou stabiel moeten zijn */
}
#countText {
font-weight: bold;
white-space: nowrap;     /* Voorkom dat tekst naar volgende regel gaat */
overflow: hidden;        /* Verberg tekst die niet past */
text-overflow: ellipsis; /* Voeg "..." toe aan afgekapte tekst */
min-width: 0;            /* Belangrijk voor ellipsis in flex items */
margin-right: 10px;      /* Ruimte tussen tekst en iconen */
/* flex-grow: 1;  Optioneel, als het moet uitdijen. Voor nu niet nodig. */
}
.icons-group {
margin-left: auto;
display: flex;
gap: 10px;
}
.sort-icon, .favorite-toggle { /* Gecombineerd voor font-display */
cursor: pointer;
color: #555;
user-select: none;
font-display: block; /* Voorkomt flash van tekst ligatures */
}
.sort-icon.active {
color: #007bff;
}
.favorite-toggle { /* Specifieke kleur voor favorite blijft apart indien nodig */
color: red;
}
#errorMessage {
display: none;
color: #a00;
background: #fdd;
padding: 10px;
border: 1px solid #a00;
border-radius: 5px;
margin-bottom: 10px;
}
#artistList {
display: flex;
flex-direction: column;
gap: 10px;
}
.artist-card {
background: #fff;
border-radius: 8px;
box-shadow: 0 2px 4px rgba(0,0,0,0.1);
padding: 15px;
position: relative;
}
.artist-card h2 {
margin: 0 0 10px;
font-size: 18px;
}
.artist-info,
.artist-description {
font-size: 14px;
line-height: 1.4;
}
.artist-info p,
.artist-description p {
margin: 6px 0;
}
.artist-name {
color: #007bff;
text-decoration: none;
}
.favorite-icon {
position: absolute;
top: 15px;
right: 15px;
width: 32px;
height: 32px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: red;
font-display: block; /* Ook voor dit icoon */
}
.spotify-iframe-container {
margin-top: 20px;
margin-bottom: 0;
height: 100px;
}
.spotify-iframe-container iframe {
border-radius: 8px;
margin: 0;
padding: 0;
display: block;
width: 100%;
height: 100%;
}
.artist-info p:first-child {
margin-top: 0;
}

mark {
    background-color: yellow;
    color: black;
    padding: 0.1em;
    border-radius: 3px;
}

body.dark-mode {
background: #282c34;
color: #abb2bf;
}
body.dark-mode .tab,
body.dark-mode .filter-button,
body.dark-mode #searchField {
background: #4b5059;
color: #c6cdd5;
border-color: #5b6069;
}
body.dark-mode .tab.active,
body.dark-mode .filter-button.active {
background: #61afef;
color: #282c34;
}
body.dark-mode #searchField::placeholder {
color: #98a0ad;
}
body.dark-mode #searchField.has-content {
background: #61afef;
color: #282c34;
}
body.dark-mode .info-container,
body.dark-mode .artist-card {
background: #3b4048;
box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
body.dark-mode .artist-name {
color: #61afef;
}
body.dark-mode .sort-icon, body.dark-mode .favorite-toggle { /* Aangepast voor gecombineerde selector */
color: #abb2bf;
}
body.dark-mode .sort-icon.active {
color: #61afef;
}
body.dark-mode .favorite-toggle { /* Dark mode specifieke kleur voor favorite */
color: #e06c75; /* Behoudt de rode tint voor favorieten */
}
body.dark-mode #errorMessage {
color: #e06c75;
background: #4b3030;
border-color: #c05050;
}
body.dark-mode .artist-card .favorite-icon {
color: #e06c75;
}
body.dark-mode .info-container #countText {
color: inherit;
}
body.dark-mode .artist-card h2 {
color: inherit;
}
body.dark-mode mark {
    background-color: #61afef;
    color: #282c34;
}
/* Algemene Material Icons styling, zodat font-display hier ook geldt */
.material-icons {
    font-display: block;
}
</style>
</head>
<body class="dark-mode">

<div class="tab-container">
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/12-juli/">Za</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/13-juli/">Zo</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/14-juli/">Ma</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/15-juli/">Di</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/16-juli/">Wo</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/17-juli/">Do</button>
<button class="tab" data-url="https://valkhoffestival.nl/speeldag/18-juli/">Vr</button>
</div>

<div class="filter-container">
<button class="filter-button" data-podium="Arc">Arc</button>
<button class="filter-button" data-podium="Boog">Boog</button>
<button class="filter-button" data-podium="Bloem">Bloem</button>
<button class="filter-button" data-podium="Club Voerweg">Voerweg</button>
<button class="filter-button" data-podium="Tuin">Tuin</button>
<button class="filter-button" data-podium="Kapel">Kapel</button>
<button class="filter-button" data-podium="Poort">Poort</button>
<input type="text" id="searchField" placeholder="Zoek..">
</div>

<div class="info-container">
<span id="countText">0 artiesten gevonden</span>
<span class="icons-group">
<span id="sortAlpha" class="sort-icon material-icons" title="Alfabetisch sorteren">sort_by_alpha</span>
<span id="sortTime" class="sort-icon material-icons" title="Sorteren op tijd">access_time</span>
<span id="favoriteToggle" class="favorite-toggle material-icons" title="Toon favorieten">favorite_border</span>
</span>
</div>

<div id="errorMessage"></div>
<div id="artistList"></div>

<script>
(function(){
const CORS_PROXY = 'https://api.codetabs.com/v1/proxy?quest=',
BASE_URL = 'https://valkhoffestival.nl',
WEEK_URL = BASE_URL + '/lineup/',
PREFIX = 'vf_',
ALL_ARTISTS_DATA_CACHE_KEY = PREFIX + 'allArtistsData_v2';

const artistListElement = document.getElementById('artistList'),
countTextElement = document.getElementById('countText'),
errorMessageElement = document.getElementById('errorMessage'),
searchFieldElement = document.getElementById('searchField'),
sortAlphaElement = document.getElementById('sortAlpha'),
sortTimeElement = document.getElementById('sortTime'),
favoriteToggleElement = document.getElementById('favoriteToggle'),
tabContainerElement = document.querySelector('.tab-container'),
filterContainerElement = document.querySelector('.filter-container');

let allArtistsData = [],
iframeObserver,
searchClickShouldClear = false; // Voor zoekveld toggle functionaliteit

const dagen = ['zondag','maandag','dinsdag','woensdag','donderdag','vrijdag','zaterdag'];
const originalHTMLMap = new WeakMap();

function getStoredJSON(keySuffix, defaultValue) {
const item = localStorage.getItem(PREFIX + keySuffix);
if (item === null) return defaultValue;
try {
return JSON.parse(item);
} catch (e) {
console.warn(`Failed to parse ${PREFIX + keySuffix} from localStorage.`, e);
localStorage.removeItem(PREFIX + keySuffix);
return defaultValue;
}
}

function setStoredJSON(keySuffix, value) {
localStorage.setItem(PREFIX + keySuffix, JSON.stringify(value));
}

function getStoredString(keySuffix, defaultValue) {
const item = localStorage.getItem(PREFIX + keySuffix);
return item === null ? defaultValue : item;
}

function setStoredString(keySuffix, value) {
localStorage.setItem(PREFIX + keySuffix, value);
}

let sortMode = getStoredString('sortMode', 'alpha'),
activePodia = getStoredJSON('activePodia', []),
favorites = getStoredJSON('favorites', []),
showingFavs = getStoredJSON('showingFavs', false),
activeDays = getStoredJSON('activeDays', []);

function capitalize(s){
if(!s) return s;
return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
}

function showError(msg){
errorMessageElement.textContent = msg;
errorMessageElement.style.display = 'block';
}
function hideError(){
errorMessageElement.style.display = 'none';
}
function getFullUrl(url){
return url.startsWith('http')
? url
: BASE_URL + (url.startsWith('/') ? '' : '/') + url;
}

function extractDayFilterFromUrl(url) {
if (url.includes('/lineup/')) return 'Week';
const match = url.match(/(\d{1,2})-([a-zA-Z]+)/i);
if (match) {
return `${parseInt(match[1], 10)} ${match[2].toLowerCase()}`;
}
return null;
}

async function fetchArtistInfo(artistBasicInfo) {
const artistCacheKey = PREFIX + 'artist_' + artistBasicInfo.name.replace(/[^a-zA-Z0-9]/g, '_');
const stored = localStorage.getItem(artistCacheKey);
if (stored) return JSON.parse(stored);

try {
const res = await fetch(CORS_PROXY + artistBasicInfo.artistUrl);
if (!res.ok) return null;
const html = await res.text();
const doc = new DOMParser().parseFromString(html, 'text/html');
const tags = Array.from(doc.querySelectorAll('.meta .tag'));
const paras = doc.querySelectorAll('.description p');

const spotifyIframe = doc.querySelector('.spotify iframe');
let spotifyId = null;
if (spotifyIframe) {
const src = spotifyIframe.getAttribute('src');
if (src) {
const match = src.match(/spotify:artist:([^&?]+)/);
if (match && match[1]) spotifyId = match[1];
}
}

const rawPodium = tags[tags.length - 3]?.textContent.trim() || 'Onbekend';
const rawDatum = tags[tags.length - 2]?.textContent.trim() || 'Onbekend';
const rawTijd = tags[tags.length - 1]?.textContent.trim() || 'Onbekend';

let duurTekst = '';
if (rawTijd.includes('-')) {
const [start, end] = rawTijd.split('-').map(s => s.trim());
const [su, sm] = start.split(':').map(n => parseInt(n, 10));
const [eu, em] = end.split(':').map(n => parseInt(n, 10));
if (!isNaN(su) && !isNaN(sm) && !isNaN(eu) && !isNaN(em)) {
let minutesStart = su * 60 + sm;
let minutesEnd = eu * 60 + em;
if (minutesEnd <= minutesStart) minutesEnd += 24 * 60;
const diff = minutesEnd - minutesStart;
if (diff > 0 && diff <= 24 * 60) duurTekst = diff + ' minuten';
}
}

const info = {
genres: tags.slice(0, -3).map(t => t.textContent.trim()),
podium: capitalize(rawPodium),
datum: rawDatum,
tijd: rawTijd,
duur: duurTekst,
description: Array.from(paras).map(p => p.textContent.trim()).filter(txt => txt).join('\n\n') || 'Geen beschrijving beschikbaar',
spotifyId: spotifyId
};
localStorage.setItem(artistCacheKey, JSON.stringify(info));
return info;
} catch (err) {
console.error(`Error fetching info for ${artistBasicInfo.name}:`, err);
return null;
}
}

async function loadAllArtistsData() {
hideError();
const cachedData = localStorage.getItem(ALL_ARTISTS_DATA_CACHE_KEY);
if (cachedData) {
try {
allArtistsData = JSON.parse(cachedData);
console.log("All artists data loaded from cache.");
return;
} catch (e) {
console.warn("Failed to parse allArtistsData from cache, fetching fresh.", e);
localStorage.removeItem(ALL_ARTISTS_DATA_CACHE_KEY);
}
}

countTextElement.textContent = 'Artiesten laden...';

try {
const res = await fetch(CORS_PROXY + WEEK_URL);
if (!res.ok) {
showError(`Kon basis artiestenlijst niet laden (status ${res.status}).`);
return;
}
const html = await res.text();
const doc = new DOMParser().parseFromString(html, 'text/html');

const artistBasicInfos = Array.from(doc.querySelectorAll('a.artist'))
.map(a => ({
name: a.querySelector('.nameplate h2').textContent.trim(),
artistUrl: getFullUrl(a.getAttribute('href'))
}));

let fetchedCount = 0;
for (const basicInfo of artistBasicInfos) {
const info = await fetchArtistInfo(basicInfo);
allArtistsData.push({
artist: basicInfo,
info: info || {
genres: [], podium: 'Onbekend', datum: 'Onbekend', tijd: 'Onbekend',
duur: '', description: 'Details konden niet geladen worden.', spotifyId: null
}
});
fetchedCount++;
countTextElement.textContent = `Details geladen voor ${fetchedCount}/${artistBasicInfos.length} artiesten...`;
}

localStorage.setItem(ALL_ARTISTS_DATA_CACHE_KEY, JSON.stringify(allArtistsData));
console.log("All artists data fetched and cached.");

} catch (err) {
console.error(err);
showError('Netwerkfout bij ophalen artiestenlijst.');
}
}

function parseDateTimeForSort(datum, tijd){
if (!datum || !tijd || datum === 'Onbekend' || tijd === 'Onbekend' || !tijd.includes(':')) return 0;

const datumParts = datum.split(' ');
if (datumParts.length < 2) return 0;
const dagNum = parseInt(datumParts[0], 10);

const startTimeStr = tijd.split('-')[0].trim();
const tijdParts = startTimeStr.split(':');
if (tijdParts.length < 2) return 0;

const u = parseInt(tijdParts[0], 10);
const m = parseInt(tijdParts[1], 10);

if (isNaN(dagNum) || isNaN(u) || isNaN(m)) return 0;
return new Date(2025, 6, dagNum, u, m).getTime();
}

function renderAllArtistCardsOnce() {
artistListElement.innerHTML = '';

allArtistsData.forEach(({ artist, info }) => {
const card = document.createElement('div');
card.className = 'artist-card';
card.style.display = 'none';

card.dataset.name = artist.name.toLowerCase();
card.dataset.podium = info.podium;
card.dataset.dag = info.datum;
card.dataset.tijdInfo = info.tijd;
card.dataset.timestamp = parseDateTimeForSort(info.datum, info.tijd);
card.dataset.rawName = artist.name;
card.dataset.genres = info.genres.join(',').toLowerCase();
card.dataset.description = info.description.toLowerCase();

const dagNum = info.datum !== 'Onbekend' ? info.datum.split(' ')[0].padStart(2, '0') : '';
let dagNaam = '';
if (dagNum) {
const date = new Date(`2025-07-${dagNum}`);
if (!isNaN(date.getTime())) {
dagNaam = dagen[date.getDay()];
}
}

const isFav = favorites.includes(artist.name);

const spotifyIframeHtml = info.spotifyId
? `<div class="spotify-iframe-container">
<iframe data-src="https://open.spotify.com/embed/artist/${info.spotifyId}?utm_source=generator"
frameBorder="0" allowfullscreen=""
allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
loading="lazy"></iframe>
</div>`
: '';

card.innerHTML = `
<h2><a href="${artist.artistUrl}" target="_blank" class="artist-name">${artist.name}</a></h2>
${spotifyIframeHtml}
<span class="favorite-icon material-icons" data-name="${artist.name}">
${isFav ? 'favorite' : 'favorite_border'}
</span>
<div class="artist-info">
<p class="highlightable-genres">Genres: ${info.genres.join(', ') || 'Geen genres'}</p>
<p class="highlightable-podium">Podium: ${info.podium}</p>
<p>Datum: ${dagNaam ? capitalize(dagNaam) + ' ' : ''}${info.datum}</p>
<p>Tijd: ${info.tijd}${info.duur ? ' (' + info.duur + ')' : ''}</p>
</div>
<div class="artist-description highlightable-description">
<p>${info.description.replace(/\n\n/g, '</p><p>')}</p>
</div>`;
artistListElement.appendChild(card);
});
setupIntersectionObserverForIframes();
}

function setupIntersectionObserverForIframes() {
const iframes = artistListElement.querySelectorAll('.spotify-iframe-container iframe[data-src]');
if (iframeObserver) iframeObserver.disconnect();

iframeObserver = new IntersectionObserver((entries, observer) => {
entries.forEach(entry => {
if (entry.isIntersecting) {
const iframe = entry.target;
if (iframe.dataset.src) {
iframe.src = iframe.dataset.src;
iframe.removeAttribute('data-src');
}
observer.unobserve(iframe);
}
});
}, { rootMargin: '200px 0px 200px 0px' });

iframes.forEach(iframe => iframeObserver.observe(iframe));
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clearHighlight(element) {
    if (element && originalHTMLMap.has(element)) {
        element.innerHTML = originalHTMLMap.get(element);
    }
}

function applyHighlight(element, searchTerm) {
    if (!element) return;

    if (!originalHTMLMap.has(element)) {
        originalHTMLMap.set(element, element.innerHTML);
    }
    
    element.innerHTML = originalHTMLMap.get(element); 

    if (!searchTerm) {
        return;
    }
    
    const escapedSearchTerm = escapeRegExp(searchTerm);
    const regex = new RegExp(escapedSearchTerm, 'gi');

    function highlightNodeRecursive(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.nodeValue;
            if (regex.test(text)) {
                const fragment = document.createDocumentFragment();
                let lastIndex = 0;
                text.replace(regex, (match, ...args) => {
                    const offset = args[args.length - 2]; 
                    if (offset > lastIndex) {
                        fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                    }
                    const mark = document.createElement('mark');
                    mark.textContent = match;
                    fragment.appendChild(mark);
                    lastIndex = offset + match.length;
                    return match; 
                });
                if (lastIndex < text.length) {
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                }
                if (fragment.childNodes.length > 0) {
                    node.parentNode.replaceChild(fragment, node);
                }
            }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName.toLowerCase() === 'mark' || node.tagName.toLowerCase() === 'script' || node.tagName.toLowerCase() === 'style') {
                return; 
            }
            Array.from(node.childNodes).forEach(highlightNodeRecursive);
        }
    }
    highlightNodeRecursive(element);
}


function applyFiltersAndSort() {
hideError();
const searchTerm = searchFieldElement.value.toLowerCase();
let visibleCount = 0;

const cardElements = artistListElement.children;

for (const card of cardElements) {
    const { name: artistNameLC, podium, dag, genres, description, rawName } = card.dataset;

    const artistNameEl = card.querySelector('.artist-name');
    const genresEl = card.querySelector('.highlightable-genres');
    const podiumEl = card.querySelector('.highlightable-podium');
    const descriptionEl = card.querySelector('.highlightable-description');
    
    clearHighlight(artistNameEl);
    clearHighlight(genresEl);
    clearHighlight(podiumEl);
    clearHighlight(descriptionEl);

    const matchesDay = !activeDays.length || activeDays.includes(dag);
    const matchesPodium = !activePodia.length || activePodia.includes(podium);
    const matchesSearch = !searchTerm ||
    artistNameLC.includes(searchTerm) ||
    description.includes(searchTerm) ||
    genres.includes(searchTerm) ||
    podium.toLowerCase().includes(searchTerm);
    const matchesFavs = !showingFavs || favorites.includes(rawName);

    if (matchesDay && matchesPodium && matchesSearch && matchesFavs) {
        card.style.display = '';
        visibleCount++;
        if (searchTerm) {
            applyHighlight(artistNameEl, searchTerm);
            if (genresEl && genresEl.textContent.toLowerCase().includes(searchTerm)) applyHighlight(genresEl, searchTerm);
            if (podiumEl && podiumEl.textContent.toLowerCase().includes(searchTerm)) applyHighlight(podiumEl, searchTerm);
            if (descriptionEl && descriptionEl.textContent.toLowerCase().includes(searchTerm)) applyHighlight(descriptionEl, searchTerm);
        }
    } else {
        card.style.display = 'none';
    }

    const favIcon = card.querySelector('.favorite-icon');
    if (favIcon) {
        favIcon.textContent = favorites.includes(rawName) ? 'favorite' : 'favorite_border';
    }
}

const cardsArray = Array.from(cardElements);

cardsArray.sort((a, b) => {
    if (sortMode === 'alpha') {
    return a.dataset.name.localeCompare(b.dataset.name);
    } else {
    const timeA = parseInt(a.dataset.timestamp, 10);
    const timeB = parseInt(b.dataset.timestamp, 10);

    const aIsUnknown = timeA === 0;
    const bIsUnknown = timeB === 0;

    if (aIsUnknown && bIsUnknown) return a.dataset.name.localeCompare(b.dataset.name);
    if (aIsUnknown) return 1;
    if (bIsUnknown) return -1;
    if (timeA === timeB) return a.dataset.name.localeCompare(b.dataset.name);
    return timeA - timeB;
    }
});

cardsArray.forEach((card, index) => {
    card.style.order = index;
});

updateArtistCount(visibleCount);
}

function updateArtistCount(n){
countTextElement.textContent =
`${n} ${showingFavs ? 'favoriet' + (n === 1 ? '' : 'en') : 'artiest' + (n === 1 ? '' : 'en')} gevonden`;
}

function updateFilterButtonsUI(){
document.querySelectorAll('.filter-button').forEach(btn=>{
btn.classList.toggle('active', activePodia.includes(btn.dataset.podium));
});
}

function updateSortIconsUI(){
sortAlphaElement.classList.toggle('active', sortMode === 'alpha');
sortTimeElement.classList.toggle('active', sortMode === 'time');
}

function updateFavoriteToggleUI() {
favoriteToggleElement.textContent = showingFavs ? 'favorite' : 'favorite_border';
favoriteToggleElement.classList.toggle('active', showingFavs);
}

function updateActiveDayTabsUI() {
    document.querySelectorAll('.tab').forEach(t => {
        const dayFilterForButton = t.dataset.dayfilter;
        t.classList.toggle('active', activeDays.includes(dayFilterForButton));
    });
}

function toggleFavoriteOnCard(name){
const idx = favorites.indexOf(name);
if(idx > -1) favorites.splice(idx,1);
else favorites.push(name);
setStoredJSON('favorites', favorites);
applyFiltersAndSort();
}

function clearLocalStorageData(){
if(!confirm('Weet je zeker dat je alle data (behalve favorieten en voorkeuren) wilt resetten? Dit kan nodig zijn na website updates.'))
return;

for(const key of Object.keys(localStorage)){
if(key.startsWith(PREFIX + 'artist_') || key === ALL_ARTISTS_DATA_CACHE_KEY){
localStorage.removeItem(key);
}
}
allArtistsData = [];
location.reload();
}

function initializeEventListeners() {
tabContainerElement.addEventListener('click', function(e) {
    const tab = e.target.closest('.tab');
    if (tab) {
        const dayFilter = tab.dataset.dayfilter;
        const index = activeDays.indexOf(dayFilter);
        if (index > -1) {
            activeDays.splice(index, 1);
        } else {
            activeDays.push(dayFilter);
        }
        setStoredJSON('activeDays', activeDays);
        updateActiveDayTabsUI();
        applyFiltersAndSort();
    }
});

document.querySelectorAll('.tab').forEach(tab => {
    tab.dataset.dayfilter = extractDayFilterFromUrl(tab.dataset.url);
});

filterContainerElement.addEventListener('click', function(e){
    const btn = e.target.closest('.filter-button');
    if(btn){
    const p = btn.dataset.podium;
    activePodia = activePodia.includes(p)
    ? activePodia.filter(x=>x!==p)
    : [...activePodia, p];
    setStoredJSON('activePodia', activePodia);
    updateFilterButtonsUI();
    applyFiltersAndSort();
    }
});

// Zoekveld event listeners
searchFieldElement.addEventListener('focus', function() {
    if (this.value.length > 0) {
        searchClickShouldClear = true;
    } else {
        searchClickShouldClear = false;
    }
});

searchFieldElement.addEventListener('click', function() {
    if (searchClickShouldClear && this.value.length > 0) {
        this.value = '';
        this.classList.remove('has-content');
        this.blur(); // Verwijder focus, probeert keyboard te sluiten
        applyFiltersAndSort();
        searchClickShouldClear = false; 
    }
});

searchFieldElement.addEventListener('input', function(){
    searchClickShouldClear = (this.value.length > 0); // Na typen, volgende klik (indien focus behouden) kan wissen
    
    this.classList.toggle('has-content', this.value.length > 0);
    const v = this.value.toLowerCase();
    if(v === 'reset' || v === 'clear') {
        this.value = '';
        this.classList.remove('has-content');
        searchClickShouldClear = false;
        clearLocalStorageData();
    } else {
        applyFiltersAndSort();
    }
});

searchFieldElement.addEventListener('blur', function() {
    searchClickShouldClear = false; // Reset als focus verloren gaat
});


sortAlphaElement.addEventListener('click', function(){
    sortMode = 'alpha';
    setStoredString('sortMode', sortMode);
    updateSortIconsUI();
    applyFiltersAndSort();
});
sortTimeElement.addEventListener('click', function(){
    sortMode = 'time';
    setStoredString('sortMode', sortMode);
    updateSortIconsUI();
    applyFiltersAndSort();
});

favoriteToggleElement.addEventListener('click', function(){
    showingFavs = !showingFavs;
    setStoredJSON('showingFavs', showingFavs);
    updateFavoriteToggleUI();
    applyFiltersAndSort();
});

artistListElement.addEventListener('click', e=>{
    const favIcon = e.target.closest('.favorite-icon');
    if(favIcon){
    toggleFavoriteOnCard(favIcon.dataset.name);
    }
});
}

async function main() {
initializeEventListeners();

updateFilterButtonsUI();
updateSortIconsUI();
updateFavoriteToggleUI();
updateActiveDayTabsUI();

await loadAllArtistsData();

if (allArtistsData.length > 0) {
    renderAllArtistCardsOnce();
    applyFiltersAndSort();
} else {
    if (!errorMessageElement.style.display || errorMessageElement.style.display === 'none') {
    showError('Geen artiesten data gevonden of kunnen laden.');
    }
    updateArtistCount(0);
}
searchFieldElement.classList.toggle('has-content', searchFieldElement.value.length > 0);
// Initialiseer searchClickShouldClear op basis van de huidige waarde (indien pagina herlaadt met waarde)
if (searchFieldElement.value.length > 0) {
    // Als er bij laden al waarde is, zou een klik moeten kunnen wissen (na focus).
    // De focus handler zal dit correct instellen.
}

}

main();

})();
</script>

</body>
</html>
